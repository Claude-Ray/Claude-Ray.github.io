<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claude&#39;s Home</title>
  <subtitle>Searching</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://claude-ray.github.io/"/>
  <updated>2018-08-26T12:52:55.428Z</updated>
  <id>https://claude-ray.github.io/</id>
  
  <author>
    <name>Claude Ray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu16.04升级18.04LTS</title>
    <link href="https://claude-ray.github.io/2018/08/23/ubuntu16to18md/"/>
    <id>https://claude-ray.github.io/2018/08/23/ubuntu16to18md/</id>
    <published>2018-08-23T13:16:15.000Z</published>
    <updated>2018-08-26T12:52:55.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="进度缓慢"><a href="#进度缓慢" class="headerlink" title="- 进度缓慢"></a>- 进度缓慢</h3><p>部分软件需要手动输入y/n来决定一些新旧配置项的取舍，长时间不去查看就会一直卡着。</p>
<h3 id="桌面崩溃"><a href="#桌面崩溃" class="headerlink" title="- 桌面崩溃"></a>- 桌面崩溃</h3><p>由于加了一些界面美化插件，非常担心桌面崩溃，果然更新了三分之一就跪了。</p>
<p>尝试注销桌面系统，过一会儿屏幕上只剩一个鼠标，凉凉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill Xorg</span><br></pre></td></tr></table></figure></p>
<p>为了恢复工作，尝试重新安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall ubuntu.desktop</span><br></pre></td></tr></table></figure></p>
<p>但提示<code>Could not get lock /var/lib/dpkg/lock</code>，尝试强制获取lock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure></p>
<p>这时再执行reinstall ubuntu.desktop时，提示需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure -a</span><br></pre></td></tr></table></figure></p>
<p>电脑硬盘不好，漫长的等待。此时一边在命令行工作，一边，等到上面指令终于执行完毕，基本上心态已崩，揣着重装系统的念头，(此时一定要做好数据备份)。</p>
<p>继续尝试重启<code>shutdown now -r</code>无效，按提示<code>systemctl reboot -i</code>成功启动</p>
<h2 id="善后"><a href="#善后" class="headerlink" title="善后"></a>善后</h2><p>惊喜是一次重启就成功了，部分软件如redshift提示无法使用，原因是缺了一些依赖，重新下载即可。</p>
<p>但是打开浏览器发现无法上网，但系统提示网线已连接，第一反应是dns，修改了<code>/etc/resolv.conf</code>没效果，又习惯性用ssh测远程连接，再次失败陷入误区。当发现使用ip和端口可以访问服务时才彻底意识到是dns的问题。</p>
<h3 id="修改dns"><a href="#修改dns" class="headerlink" title="- 修改dns"></a>- 修改dns</h3><p>ubuntu修改dns两种方式，并不包含直接修改<code>/etc/resolv.conf</code>。</p>
<p>编辑<code>/etc/resolvconf/resolv.conf.d/base</code>，文件初始内容为空，加上<code>nameserver 8.8.8.8</code>，之后需执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure></p>
<p>才会正确生效并写入<code>/etc/resolv.conf</code>。</p>
<p>另一种方式是直接修改<code>/etc/network/interfaces</code>。</p>
<h3 id="修复ssh"><a href="#修复ssh" class="headerlink" title="- 修复ssh"></a>- 修复ssh</h3><p>升级之后使用ssh提示<code>permission denied (publickey)</code>，最快排查办法是带上参数<code>-vvv</code>，我这里的错误是未指定私钥文件，使用<code>-i</code>加私钥路径可解。</p>
<p>当然不想每次都-i，因此可以将公钥私钥放在id_rsa，id_rsa.pub。同时不想每次都输入密码，执行<code>ssh-add ~/.ssh/id_dsa</code>。</p>
<p>注意密钥权限只能属于使用者，文件400权限就好，超过权限范围会提示Permissions too open。</p>
<h3 id="18-04部署攻略"><a href="#18-04部署攻略" class="headerlink" title="- 18.04部署攻略"></a>- 18.04部署攻略</h3><p>重装redshift时发现有人整理了一些安装指令，可以方便大家部署新系统。</p>
<p><a href="https://github.com/erikdubois/Ultimate-Ubuntu-18.04" target="_blank" rel="noopener">https://github.com/erikdubois/Ultimate-Ubuntu-18.04</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于桌面系统相当脆弱，一定要通过命令行来完成升级，也方便处理异常。出现问题升级不一定中断，不要急着重启，避免让问题严重到系统无法访问。</p>
<p>不要听信网上的无痛升级论，做好数据备份，谨慎操作。</p>
<h3 id="16-08-24更新"><a href="#16-08-24更新" class="headerlink" title="16-08-24更新"></a>16-08-24更新</h3><p>桌面系统再次崩溃，详情可以看这个<a href="https://bugs.launchpad.net/ubuntu/+source/gdm3/+bug/1779476" target="_blank" rel="noopener">Bug</a>，并且在论坛找到了非常相似的<a href="https://ubuntuforums.org/showthread.php?t=2391542" target="_blank" rel="noopener">遭遇</a>。</p>
<p>起初还不清楚是什么状况，试过了swapoff，gnome重装，gdm3降级，切换lightdm等等，看到bug反馈时终于决定接受了各位前人的重装解决方案。</p>
<p>顺便碰到了双系统不能上网问题，修复较容易，BIOS 关闭<code>wake on lan</code>，如果已经关闭就重新打开再关闭。</p>
]]></content>
    
    <summary type="html">
    
      上个月第一次收到升级推送，当时工作较重又担心出现问题就拒绝了。今天又收到推送，恰好本地没有怕丢的代码，但是经验不足，直接通过推送窗口点击了同意，接下来虚惊一场。次日，桌面系统再次崩溃，强烈建议不要升级而是彻底重装!
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://claude-ray.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>阿里云验证码node接入</title>
    <link href="https://claude-ray.github.io/2018/07/31/%E9%98%BF%E9%87%8C%E4%BA%91%E9%AA%8C%E8%AF%81%E7%A0%81node%E6%8E%A5%E5%85%A5/"/>
    <id>https://claude-ray.github.io/2018/07/31/阿里云验证码node接入/</id>
    <published>2018-07-31T14:51:14.000Z</published>
    <updated>2018-08-08T15:37:38.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h2><p>首先放出<del>不是那么</del>重要的文档地址。</p>
<p>我认为值得看的是使用说明中的流程图，其他感兴趣的信息可以在文档左侧菜单查找。</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66306.html" target="_blank" rel="noopener">滑动验证使用说明</a></li>
<li><a href="https://help.aliyun.com/document_detail/66349.html" target="_blank" rel="noopener">签名机制</a></li>
<li><a href="https://develop.aliyun.com/tools/sdk" target="_blank" rel="noopener">阿里云全部SDK</a></li>
</ul>
<p>明明很重要的参数说明，太坑了，看不看都一样。</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66340.html" target="_blank" rel="noopener">验证码服务端API</a></li>
<li><a href="https://help.aliyun.com/document_detail/66348.html" target="_blank" rel="noopener">公共参数</a></li>
</ul>
<h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><p>不得不说接入过程比geetest痛苦多了，后续会上传相关代码以供参考。关键是阿里云验证码版本号太多，我不想维护一个非官方SDK，因此也不会发布npm。</p>
<h3 id="1-阿里云控制台"><a href="#1-阿里云控制台" class="headerlink" title="1. 阿里云控制台"></a>1. 阿里云控制台</h3><ul>
<li>添加用户，拿到<code>AccessKeyID</code>和<code>AccessKeySecret</code></li>
<li>在<code>安全</code>-&gt;<code>数据风控</code>配置验证码，拿到<code>AppKey</code>，同时可获取接入demo。(虽然配置时要选择使用场景，而且只能靠单选生成一个<code>original scene</code>，实际使用时<code>Scene</code>参数可以自定义传递。)</li>
</ul>
<h3 id="2-下载其他版本SDK"><a href="#2-下载其他版本SDK" class="headerlink" title="2. 下载其他版本SDK"></a>2. 下载其他版本SDK</h3><p>很有必要，踩的坑全靠这一步来填。这里选择了php版sdk，前面提到阿里文档的参数并不准确，重点看以下文件补全参数。</p>
<ul>
<li><code>aliyun-php-sdk-afs/afs/Request/V20180112/AuthenticateSigRequest.php</code></li>
<li><code>aliyun-php-sdk-core/RpcAcsRequest.php</code></li>
</ul>
<h3 id="3-计算签名"><a href="#3-计算签名" class="headerlink" title="3. 计算签名"></a>3. 计算签名</h3><p>官方文档还算详细，更方便的是直接参考阿里云node-sdk的开源实现，如<code>https://github.com/willin/waliyun</code>。</p>
<blockquote>
<p>请求方式的不同，会决定signature是否需要经过编码。</p>
</blockquote>
<h3 id="4-HTTPS请求"><a href="#4-HTTPS请求" class="headerlink" title="4. HTTPS请求"></a>4. HTTPS请求</h3><p>GET和POST都支持，只需留意签名计算的区别。<br>为了避免各种请求模块对参数的编码进行再次转换，省心的做法是拼接完整url后使用GET请求。</p>
<h3 id="5-付费模式"><a href="#5-付费模式" class="headerlink" title="5. 付费模式"></a>5. 付费模式</h3><p>友情提示一下，官网明说<code>免费调用周期7天</code>，结果试用两天就收到0.08元欠费通知，找了半天没看到扣费明细，心塞T_T</p>
<p>应该是直接进入了后付费模式，因此测试时请做好心理准备。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不可轻信文档，特别是神奇的日期格式版本号Version，公共参数居然给定了取值<code>2016-11-23</code>，但没给验证地址。</p>
<p>事实上新旧Version的验证地址并不相同。在不知情时用错误地址进行校验，一直提示InvalidVersion，并且没有对应的错误返回值文档。</p>
<p>除了验证地址，不同Version下需要提交的必选参数也不同，详情需要去其他版本SDK挖掘。</p>
<p>看得出文档内容比前人吐槽的时候丰富了不少，望相关开发人员及时更新。</p>
<h3 id="SDK实现"><a href="#SDK实现" class="headerlink" title="SDK实现"></a>SDK实现</h3><p><a href="https://github.com/Claude-Ray/aliyun-captcha" target="_blank" rel="noopener">aliyun-captcha</a></p>
]]></content>
    
    <summary type="html">
    
      分享接入过程和心得
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Captcha" scheme="https://claude-ray.github.io/tags/Captcha/"/>
    
  </entry>
  
  <entry>
    <title>解决svn没有merge全部更改的问题</title>
    <link href="https://claude-ray.github.io/2018/03/19/%E8%A7%A3%E5%86%B3svn%E6%B2%A1%E6%9C%89merge%E5%85%A8%E9%83%A8%E6%9B%B4%E6%94%B9%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://claude-ray.github.io/2018/03/19/解决svn没有merge全部更改的问题/</id>
    <published>2018-03-19T03:53:52.000Z</published>
    <updated>2018-03-19T16:59:53.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天使用svn合并主干到发布分支时，发现即使没有冲突，也出现了文件错误。检查后发现，文件内有一部分历史更改被遗漏了。</p>
<p>准确的说，上一次合并开发分支到主干后，由于只想发布个别文件（individual files），在发布分支merge拉取后只选择性的commit了4个文件，其他的文件（并非首次创建）更改自此忽略。记本次为操作A。</p>
<p>正常情况下，重新执行merge，仍然可以看到未提交的改动文件，但本次merge隔操作A数个版本之后，<code>mergeinfo</code>也并不会显示操作A漏掉的提交。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="1-ignore-ancestry"><a href="#1-ignore-ancestry" class="headerlink" title="1. ignore ancestry"></a>1. ignore ancestry</h3><p>除了操作A之外，也有很多其他只提交特定文件的merge记录，所以直接加<code>--ignore-ancestry</code>，甚至出现了以下错误导致无法合并。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn: E200004: Cannot merge automatically <span class="keyword">while</span> ignoring mergeinfo</span><br></pre></td></tr></table></figure></p>
<h3 id="2-指定版本号"><a href="#2-指定版本号" class="headerlink" title="2. 指定版本号"></a>2. 指定版本号</h3><p>指定被漏掉更改的那个版本号（例如r233），可以只找回当时漏提交的文件(使用参数<code>-c</code>, 限定ARG-1:ARG的修改)。</p>
<p>完整命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge --ignore-ancestry -c 233 http://localhost/svn/url</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>笔者对svn使用仍不够熟练，一直使用命令行操作，可能这也是触发霉头的根源。 XD</p>
<p>粗略浏览了Stack Overflow，没看到期望的答案，但有些回答也给我一些启发，捡一条附在了下面。</p>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p><a href="https://stackoverflow.com/questions/754082/merging-across-branches-in-subversion-isnt-adding-all-the-new-files-why-not" target="_blank" rel="noopener">Merging across branches in Subversion isn’t adding all the new files. Why not?
</a></p>
<p>The following statement is not true:</p>
<blockquote>
<p>Files that were added to a branch and then changed on the branch don’t get added when doing a merge across number of revisions</p>
</blockquote>
<p>That would imply merging is totally broken.</p>
<p>When you do the merge, you need to make sure that you do merge the revision that created the file, otherwise you’ll get those warnings about no target.</p>
<p>The other thing to watch out for is if you do a merge into a working copy, then decide you’re not happy with it and revert everything, the newly added files will still be in the working copy, so if you merge again, the unversioned files will prevent the merge of new files there, so you will miss them. So running “svn status” and removing unversioned files will ensure the merge works properly.</p>
<p>The comment about adding an empty file should not be done, because then the new file has no history of where it came from. In other words, it’s not a copy, so “svn log” will not show its history. And finally, if the file were a gigabyte photo, you wouldn’t want to merge it into a new file, because then the repository would have two copies of the exact same context. Merging and copying with history saves repository storage (at least until rep-sharing is put in).</p>
]]></content>
    
    <summary type="html">
    
      记一次svn merge individual files导致后续merge遗漏更改的解决方案。
    
    </summary>
    
      <category term="SVN" scheme="https://claude-ray.github.io/categories/SVN/"/>
    
    
      <category term="SVN" scheme="https://claude-ray.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>request中文乱码问题</title>
    <link href="https://claude-ray.github.io/2018/02/26/request%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://claude-ray.github.io/2018/02/26/request中文乱码问题/</id>
    <published>2018-02-26T14:16:20.000Z</published>
    <updated>2018-02-26T14:19:56.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>可能是需要开启<code>gzip: true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;url, <span class="attr">gzip</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="buffer-decode"><a href="#buffer-decode" class="headerlink" title="buffer decode"></a>buffer decode</h3><p>可以考虑使用<code>iconv-lite</code>转换buffer。request设置<code>encoding: null</code>时，会返回buffer形式的body。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;url, <span class="attr">gzip</span>: <span class="literal">true</span>, <span class="attr">encoding</span> : <span class="literal">null</span>&#125;, (err, res, body) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> str = iconv.decode(body, <span class="string">'gb2312'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有个别网站编码不统一，时而gb2312时而utf8，这种情况需要自己判断处理。<br>可以参考<a href="https://cnodejs.org/topic/545de1e1a68535a174fe51b5" target="_blank" rel="noopener">cnode的回帖</a>——<br>先请求下来 Buffer, 也就是 request 的时候指定 encoding: null ，得到 Buffer, 用ASCII解码前一千个字符，用正则，匹配出 ; charset=(\w+)”，得到正确的 charset, 再用 iconv-lite 解码出全部的  buff。</p>
</blockquote>
<h3 id="stream-pipe"><a href="#stream-pipe" class="headerlink" title="stream pipe"></a>stream pipe</h3><p>简化一下过程，<code>iconv-lite</code>也支持pipe<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(url).pipe(iconv.decodeStream(code));</span><br></pre></td></tr></table></figure></p>
<p>Demo</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">url, code = <span class="string">'gb2312'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = <span class="string">'something.txt'</span>;</span><br><span class="line">  <span class="keyword">const</span> tempname = <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.txt`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> writeStream = fs.createWriteStream(tempname);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      request(url)</span><br><span class="line">        .pipe(iconv.decodeStream(code))</span><br><span class="line">        .pipe(writeStream)</span><br><span class="line">        .on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">          fs.renameSync(tempname, filename);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;url&#125;</span>文件下载失败,<span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Node中使用request请求得到的数据为乱码，分析可能的情况并列举解决方案。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>使用chokidar监视文件更新</title>
    <link href="https://claude-ray.github.io/2018/01/27/%E4%BD%BF%E7%94%A8chokidar%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0/"/>
    <id>https://claude-ray.github.io/2018/01/27/使用chokidar监视文件更新/</id>
    <published>2018-01-27T04:57:42.000Z</published>
    <updated>2018-01-27T05:21:12.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监视文件"><a href="#监视文件" class="headerlink" title="监视文件"></a>监视文件</h2><p>使用<code>chokidar</code>，可以监视指定路径下目录、文件的变动。由于我只关注更改，因此监视<code>change</code>事件即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chokidar = <span class="built_in">require</span>(<span class="string">'chokidar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = watchChange;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听目录或文件变动</span></span><br><span class="line"><span class="comment"> * @param &#123;string|array&#125; paths    目录或文件路径</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125;     onChange 回调函数</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise.&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchChange</span>(<span class="params">paths, onChange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`onChange (<span class="subst">$&#123;onChange&#125;</span>) is not a function`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(paths)) paths = [paths];</span><br><span class="line"></span><br><span class="line">  paths.forEach(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(path &amp;&amp; fs.existsSync(path))) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`can't find path <span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  chokidar.watch(paths)</span><br><span class="line">    <span class="comment">// .on('add', filepath =&gt; &#123;console.log('you can watch more events by chains')&#125;)</span></span><br><span class="line">    .on(<span class="string">'change'</span>, filepath =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> filename = path.basename(filepath);</span><br><span class="line">      onChange(filename);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>为了避免每次取内容都读文件，使用了<code>lodash.memoize</code>缓存读取结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getFile = _.memoize(readFile);</span><br></pre></td></tr></table></figure>
<p>要更新这部分缓存，可以使用如下方法。用大文件测试了内存占用，没有泄露产生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFile.cache.set(file, readFile(file));</span><br></pre></td></tr></table></figure>
<p>完整部分，加上了try catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchTpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    watchFiles(<span class="string">'./test'</span>, file =&gt; &#123;</span><br><span class="line">      getFile.cache.set(file, readFile(file));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watchTpl();</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于使用场景明确，代码实现较简单，没有考虑太多情况，也算不上热更新。但借这种思路，可以完成配置文件甚至功能模块的更新。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://ngtmuzi.com/Node监视文件以实现热更新/" target="_blank" rel="noopener">Node监视文件以实现热更新</a><br><a href="http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/" target="_blank" rel="noopener">Node.js Web应用代码热更新的另类思路</a></p>
]]></content>
    
    <summary type="html">
    
      为了提高文件读取效率，有时会将文件内容缓存到内存再使用。但是当文件发生更改，如何将改动更新到缓存而又不重启Node进程。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Array.map(parseInt)为什么返回了NaN</title>
    <link href="https://claude-ray.github.io/2017/12/23/Array-map-parseInt-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E4%BA%86NaN/"/>
    <id>https://claude-ray.github.io/2017/12/23/Array-map-parseInt-为什么返回了NaN/</id>
    <published>2017-12-23T11:29:48.000Z</published>
    <updated>2017-12-23T11:35:36.042Z</updated>
    
    <content type="html"><![CDATA[<p>为什么没有得到想要的<code>[1, 2, 3]</code>？先来看parseInt的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(string, radix);</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>string</code>是必传参数，要被解析的字符串，排在起始处的空格会被忽略。</li>
<li><code>radix</code>这是可选参数，但不了解的话就容易踩坑。它是一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。例如10代表十进制。此外，不指定该参数或0，均表示为以十进制。如果以<code>0x</code> 或 <code>0X</code> 开头，表示十六进制。</li>
</ul>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>parseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。</p>
<p>基数大于 10 时，用字母表中的字母来表示大于 9 的数字。例如十六进制中，使用 A 到 F。</p>
<h3 id="一些细节（keng）"><a href="#一些细节（keng）" class="headerlink" title="一些细节（keng）"></a>一些细节（keng）</h3><ol>
<li><p>一些数中可能包含e字符（例如6.022e23），使用parseInt去截取包含e字符数值部分会造成难以预料的结果。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.022e23'</span>, <span class="number">10</span>); <span class="comment">// 返回 6</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.022e2'</span>, <span class="number">10</span>);  <span class="comment">// 返回 602</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当parseInt遇到不属于radix参数所指定的基数中的字符（eg: 有人告诉你<code>0103101</code>是2进制），那么该字符（3）和其后的字符（101）都将被忽略，接着返回已经解析的整数部分（010）。parseInt 将截取整数部分，开头和结尾的空白符允许存在，会被忽略。那么NaN的出现情况就是，<code>string</code>的第一个字符（除空白）不属于radix指定进制时，因为parseInt什么都没有解析到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="string">'afdsaf'</span>); <span class="comment">// 返回123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：</p>
<ul>
<li>string 以’0x’或者’0X’开头, 则基数是16 (16进制).</li>
<li>string 以’0’开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li>
<li>string 以其它任何值开头，则基数是10 (十进制)。</li>
</ul>
</li>
<li><p>将整型数值以特定基数转换成它的字符串值可以使用 <code>intValue.toString(radix);</code></p>
</li>
</ol>
<h2 id="Array-map"><a href="#Array-map" class="headerlink" title="Array.map"></a>Array.map</h2><p>其实看完parseInt的文档就已经清晰了，再来看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">map</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>通常情况下，<code>callback</code> 只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。</p>
<ul>
<li><code>callback</code>: 生成新数组元素的函数，使用三个参数：<ul>
<li><code>currentValue</code>: 正在处理的当前元素。</li>
<li><code>index</code>: 当前元素的索引。</li>
<li><code>array</code>: map 方法被调用的数组。</li>
</ul>
</li>
<li><code>thisArg</code>: 可选，执行 callback 函数时 使用的this 值。</li>
</ul>
<blockquote>
<p>返回值是一个新数组，每个元素都是回调函数的值。</p>
</blockquote>
<h2 id="最终分析"><a href="#最终分析" class="headerlink" title="最终分析"></a>最终分析</h2><p>调用<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(console.log)</code>观察，列举出当<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>的时候发生了什么。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br></pre></td></tr></table></figure></p>
<p>由于parseInt只接受了前两个参数，过滤掉array得到如下。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>); <span class="comment">// radix为0，按十进制输出1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>); <span class="comment">// radix为1，不满足2到36范围</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>); <span class="comment">// radix为2，将3看成二进制数，但3并不是二进制，无法转换</span></span><br></pre></td></tr></table></figure></p>
<p>再换一个数组，也可以按照此逻辑推算正确结果了。</p>
]]></content>
    
    <summary type="html">
    
      简单来说，当调用`[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)`的时候，会返回什么结果？答案是`[1, NaN, NaN]`。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="JavaScript" scheme="https://claude-ray.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>缓存不当至服务崩溃</title>
    <link href="https://claude-ray.github.io/2017/12/20/%E7%BC%93%E5%AD%98%E4%B8%8D%E5%BD%93%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%B4%A9%E6%BA%83/"/>
    <id>https://claude-ray.github.io/2017/12/20/缓存不当至服务崩溃/</id>
    <published>2017-12-20T14:45:20.000Z</published>
    <updated>2017-12-21T14:51:07.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>9月份优化的redis写缓存冲突，埋下了一个地雷。</p>
<p>回顾之前的解决方案：</p>
<p>recommend接口的返回值使用非常频繁，为了避免前端不断请求recommend接口，因此前端负责写缓存，后端负责从sql中查询数据，需要更新时再去删除此缓存。</p>
<p>这样就留下一个问题，当前端缓存过期，会迸发大量的请求到后端，当后端的sql查询速度较慢。此时前端的请求不间断，后端就堆积了大量的sql查询，影响到其他请求，甚至宕机。</p>
<p>之前没有出现问题的原因，是sql走了索引，查询速度正常。恰巧这个项目被交接之后，优化的过程中发现这条索引不合理，被删除了，但是遗漏了对recommend的修改，于是导致接口超时（查询时间大于Nginx配置的最大响应时间）。且缓存时间一周，等到它自然过期，被搞得措手不及。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>立即为recommend设置一个非空缓存，停掉前端请求</li>
<li>重启mysql</li>
<li>恢复之前的索引，保证该接口下的SQL查询处于正常水平</li>
</ol>
<blockquote>
<p>旧索引恢复之后，一些优化就失效了，mysql继续走了它自认为不错的毒瘤索引。要即刻进行后续工作。</p>
</blockquote>
<h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><ol>
<li>优化此处低效的sql(select xx where xx in xx order by，没有索引自然会崩)</li>
<li>恢复后端在该接口下写缓存的能力，使用锁（redis.setnx）或让前端走请求方式获取</li>
<li>重新删除上述索引，恢复正常优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      记录此次Bug原因和修复过程
    
    </summary>
    
      <category term="Redis" scheme="https://claude-ray.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode+evernote云笔记</title>
    <link href="https://claude-ray.github.io/2017/12/05/vscode-evernote%E4%BA%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://claude-ray.github.io/2017/12/05/vscode-evernote云笔记/</id>
    <published>2017-12-05T15:40:53.000Z</published>
    <updated>2017-12-05T16:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-Evernote"><a href="#Why-Evernote" class="headerlink" title="Why Evernote"></a>Why Evernote</h1><p>之前一直使用有道云来保存笔记，支持markdown，免费的功能满足笔记所用，界面也还算可以。缺点是有广告，还经历了几次服务崩溃和笔记丢失，虽然联系客服又找回来了，但终究是越用越不爽。</p>
<p>支持markdown的云笔记非常多，可以凭喜好选择。但要说云笔记软件哪款做的最好，我更倾心于evernote。</p>
<p>evernote作为知识收藏库非常便捷，然而只有markdown才能支撑我将它作为笔记端使用。之前不使用它的唯一原因就是不支持markdown的预览，但想让它存储markdown的方法却非常多。</p>
<h1 id="云编辑"><a href="#云编辑" class="headerlink" title="云编辑"></a>云编辑</h1><p>开源的markdown云笔记：</p>
<ul>
<li>Leanote 看到知乎的吐槽，伪开源，自建服务器会很坑</li>
<li><a href="https://stackedit.io/" target="_blank" rel="noopener">Stack Edit</a>，对中文支持不太友好，可同步到Google Drive，Dropbox和github。</li>
</ul>
<p>如果不介意笔记安全，可以购买以下这类第三方服务</p>
<ul>
<li><code>马克飞象</code> 试用后认为很赞，但是一人维护也难免出现一些bug</li>
<li><code>小书匠</code> 免费不开源，界面不喜欢</li>
<li><code>有道云笔记</code> 免费够用</li>
<li><code>为知笔记</code> 要付费使用</li>
<li><code>作业部落Cmd</code></li>
<li>…</li>
</ul>
<p>有兴趣可以自己比较优劣，只能说试用过后，上面都不是我想要的，不过多赘述。</p>
<h1 id="本地编辑"><a href="#本地编辑" class="headerlink" title="本地编辑"></a>本地编辑</h1><p>文档断电丢失的担忧是过去式了，本地编辑方便使用熟悉的快捷键和指法，可以提高编辑效率。</p>
<p>如果你接受在本地编辑，或者在离线环境下写东西，联网之后再保存笔记到云端，那么就来尝试这种方法吧。</p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>所见即所得。</p>
<p>把编辑和预览结果放在了一个文本框中，对于习惯裸写markdown的无所谓，但的确是一种不错的风格。</p>
<p>绑定网盘之后可以将md文件同步到网盘上，仍然和我理想中的云笔记有差距。对我个人来说，云笔记更重要的功能是阅读而不是编辑，方便随时查阅。</p>
<h2 id="Evermonkey"><a href="#Evermonkey" class="headerlink" title="Evermonkey"></a>Evermonkey</h2><p>如果你使用sublime，应该知道有一款<code>sublime-evernote</code>插件可以使本地的markdown同步到evernote笔记中。而我更常用vscode，对markdown原生的支持就不错。vscode的一款开源插件<code>evermonkey</code>，也实现了同样的功能。</p>
<h3 id="缺憾"><a href="#缺憾" class="headerlink" title="缺憾"></a>缺憾</h3><ol>
<li>不支持双向编辑，markdown的终稿放在博客，或者打包成附件加到该笔记中更合适。</li>
<li><code>[TOC]</code>的bug？目录树可以生成，但是在印象笔记中点击链接无法跳转到正确位置。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>ever new</code> 新建笔记</li>
<li><code>ever publish</code> 发布笔记</li>
<li><code>ever recent</code> 打开最近编辑的笔记</li>
<li><code>ever open</code> 可按照目录树逐级打开</li>
<li><code>ever search</code> 使用evernote的搜索接口</li>
<li><code>ever attach</code> 添加附件</li>
<li><code>ever resources</code> 查看现在添加了哪些附件</li>
<li><code>ever unattach</code> 删除附件</li>
</ul>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>不幸的是，evernote禁止了<code>developer tokens</code>的申请，已经拥有tokens的用户将不受影响。</p>
<p>但这并不代表新用户无法使用tokens了，你可以写下申请原因，以向evernote提交<code>tickets</code>的形式来申请tokens。按照官网的说法可能要一周才回复，实际上不到半天我就收到了客服的批准答复。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>不建议在工具“选择”上浪费太多时间，愿意折腾就都玩一遍，不想折腾就认清自己的需求，选择一款方便转移文档（跑路）的即可。新的工具层出不穷，时下更成熟的那款终会浮现出现。</p>
<p>工具不能提升技术，但是可以提高效率。信仰加成~</p>
]]></content>
    
    <summary type="html">
    
      个人笔记这种重要东西，放在墙内是不放心的，由于内容基础又杂乱，不能像博客一样托管到github或gitbook，适合单独找一个地方存放。由于习惯使用Markdown记录笔记，主要为了查阅方便，我上个月瞄向了不支持Markdown格式的Evernote，借插件实现Markdown笔记存储。
    
    </summary>
    
      <category term="随笔" scheme="https://claude-ray.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>9月踩的坑</title>
    <link href="https://claude-ray.github.io/2017/10/05/9%E6%9C%88%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <id>https://claude-ray.github.io/2017/10/05/9月踩的坑/</id>
    <published>2017-10-05T01:15:09.000Z</published>
    <updated>2017-12-06T15:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lodash版本问题"><a href="#lodash版本问题" class="headerlink" title="lodash版本问题"></a>lodash版本问题</h2><p>近期更新了lodash包，<code>3.x</code> 到最新的 <code>4.17.x</code>，然后就发现系统拿不到数据了。</p>
<p>最终定位到 <code>lodash.merge</code> 方法。</p>
<p>lodash.merge有一个常用的特性，即._merge(source, […abc])，merge会自动过滤到后面参数中undefined的属性。然而，<code>4.17.x</code> 的 lodash 不再支持。这个是根据论坛其他人的评论和官方的history.md发现的，然而一年过去了，lodash的官方文档却没有更新这一点……</p>
<p>如果仍想用到过滤 <code>undefined</code> 的特性，就需要使用 <code>_.omitBy(myObj, _.isNil)</code> 或者 <code>_.pickBy(myObj)</code> 包装或替换原使用 <code>_.merge(myObj, [...source])</code> 的地方。</p>
<h2 id="写缓存冲突"><a href="#写缓存冲突" class="headerlink" title="写缓存冲突"></a>写缓存冲突</h2><p>有两个项目分别在两台服务器上pm2开5个进程，并且都具备读写一个缓存的操作，发生了写缓存冲突，导致缓存中数据写入不完整。</p>
<p>限制为只有一个项目写即可解决。</p>
<h2 id="npm安装失败"><a href="#npm安装失败" class="headerlink" title="npm安装失败"></a>npm安装失败</h2><p>升级lodash的过程中，在某个服务器失败了，报错内容为：</p>
<blockquote>
<p>nnpm ERR! path /var/xxx/node_modules/fs-extra_back/node_modules/graceful-fs/node_modules/natives npm ERR! code ENOENT npm ERR! errno -2 npm ERR! syscall access npm ERR! enoent ENOENT: no such file or directory, access ‘/var/xxx/node_modules/fs-extra_back/node_modules/graceful-fs/node_modules/natives’ npm ERR! enoent This is related to npm not being able to find a file. npm ERR! enoent npm ERR! A complete log of this run can be found in: npm ERR! /root/.npm/_logs/2017-09-29T07_39_30_928Z-debug.log</p>
</blockquote>
<p>google了一下 <code>ENOENT</code> 相关错误，提取众人反映问题的共同点就是，npm5。在npm4甚至3的环境下是没有这种情况的，服务器也是近期升级了npm版本。<br>不过比起npm降级，采取了更简便的方法，将access ‘/xxx’的npm包删除就好啦~</p>
]]></content>
    
    <summary type="html">
    
      记录9月份踩的一些坑，redis缓存和npm包的安装。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Node获取GBK编码字符串</title>
    <link href="https://claude-ray.github.io/2017/10/05/node%E8%8E%B7%E5%8F%96GBK%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://claude-ray.github.io/2017/10/05/node获取GBK编码字符串/</id>
    <published>2017-10-05T00:50:46.000Z</published>
    <updated>2018-04-19T16:04:06.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UTF8-to-GBK-Hex-String"><a href="#UTF8-to-GBK-Hex-String" class="headerlink" title="UTF8 to GBK Hex String"></a>UTF8 to GBK Hex String</h1><h2 id="iconv-lite"><a href="#iconv-lite" class="headerlink" title="iconv-lite"></a>iconv-lite</h2><p>通常都会使用 <code>iconv-lite</code> 这个包实现Node的编码转换，但是这个包是基于 <code>Buffer</code> 的，如果传递给其他语言的系统，需要先转换为 <code>String</code> 字符串。</p>
<p>在网上查阅了相关资料，并没有给出很好的解答。一些比较老的回答都在说，Node中无法把Buffer转换成gbk字符串。</p>
<p>俗话说有问题找师兄，果然，咨询同组师兄后得到了期望的结果。转换过程很巧妙，在此分享出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toGBKString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iconv.encode(str, <span class="string">'gbk'</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span><span class="subst">$&#123;cur.toString(<span class="number">16</span>)&#125;</span>`</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是不加百分号的，如果需要可以在模板字符串中自行加上。</p>
<h2 id="2018-04-18更"><a href="#2018-04-18更" class="headerlink" title="2018-04-18更"></a>2018-04-18更</h2><p>由于<code>Buffer</code>本身支持hex的转换</p>
<blockquote>
<p>Buffer instances are commonly used to represent sequences of encoded characters such as UTF-8, UCS2, Base64, or even Hex-encoded data. It is possible to convert back and forth between Buffer instances and ordinary JavaScript strings by using an explicit character encoding.</p>
</blockquote>
<blockquote>
<p>‘hex’ - Encode each byte as two hexadecimal characters.</p>
</blockquote>
<p>因此<code>reduce</code>可以继续简化为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv.encode(str, <span class="string">'gbk'</span>).toString(<span class="string">'hex'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Node下如何获取GBK编码的字符串
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="String" scheme="https://claude-ray.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Express源码分析</title>
    <link href="https://claude-ray.github.io/2017/07/24/Express%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://claude-ray.github.io/2017/07/24/Express源码分析/</id>
    <published>2017-07-24T14:54:05.000Z</published>
    <updated>2017-07-24T15:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express源码分析"><a href="#Express源码分析" class="headerlink" title="Express源码分析"></a>Express源码分析</h1><h2 id="项目整体结构"><a href="#项目整体结构" class="headerlink" title="项目整体结构"></a>项目整体结构</h2><p>相较于 <code>4.15.2</code> ， <code>4.15.3</code> 又一次移除了所有内部<code>node_modules</code>，目录结构恢复整洁。</p>
<blockquote>
<p><code>4.15.2</code> 中的内置的 <code>node_modules</code> 是 <code>debug</code>。</p>
</blockquote>
<h2 id="Express-内部文件"><a href="#Express-内部文件" class="headerlink" title="Express 内部文件"></a>Express 内部文件</h2><h3 id="1-程序入口-index-js"><a href="#1-程序入口-index-js" class="headerlink" title="1 程序入口 index.js"></a>1 程序入口 <code>index.js</code></h3><p>只是一个简单的入口，导出了<code>lib/express</code>。</p>
<h3 id="2-应用创建-express-js"><a href="#2-应用创建-express-js" class="headerlink" title="2 应用创建 express.js"></a>2 应用创建 <code>express.js</code></h3><ol>
<li><p>从入口程序进入这里，第一句就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = module.exports = createApplication;</span><br></pre></td></tr></table></figure>
<p>对这个写法进行总结：</p>
<ul>
<li>API文档中有详细解释， <code>exports</code> 就是一个shortcut。所有供外部调用的方法或变量均需挂载在exports变量上，<br>当需要将一个文件当做一个类导出时，就需要通过 <code>module.exports</code> 而不是 <code>exports</code>。</li>
<li>进一步讲讲， <code>exports</code> 是 <code>module.exports</code> 的引用，他们的初值都是空对象 <code>{}</code>。<br>require加载模块时使用的是 <code>module.exports</code> 而不是 <code>exports</code>。<br>搞不清楚关系的一直使用<code>module.exports</code>也没问题。</li>
<li>module.exports 指向新的对象时，exports 断开了与 module.exports 的引用。<br>而API上的说法不然， <code>When the module.exports property is being completely replaced by a new object, it is common to also reassign exports</code> 。<br>起初我从直观上理解，认为两者说辞是相反的，且经过验证，exports 确实会断开引用。因此是对API说明的理解有偏差。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面写法等价于</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.exports 指向新的对象时，exports 断开了与 module.exports 的引用</span></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br><span class="line"><span class="comment">// 若还想使用exports添加属性，让 exports 重新指向 module.exports 即可</span></span><br><span class="line">exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>express.js</code> 返回一个 app 作为 <code>createApplication</code> 的回调函数每个http请求都可以触发执行 <code>app.handle</code> 来执行中间件。<br><code>app.handle</code> 调用了router组件的 <code>handle(req, res, out)</code> 函数链式执行中间件。<br>通过 <a href="#merge-descriptors"><code>merge-descriptors</code></a> 中间件将 <code>application</code> 和 <code>events.EventEmitter</code> 合并(类似于继承)到 app 中。<br>而 <code>app.request</code> 和 <code>app.response</code> 通过 <code>Object.create</code> 方式继承request和response得到。完成以上操作后，调用 <code>application.init()</code> 进行初始化。</p>
</li>
<li>通过 <code>exports</code> 暴露出 express 内主要的构造器、原型。</li>
<li>末尾处遍历的数组内是已经移除的 <code>Express 3.x</code> 内置模块，当使用者不知情而直接使用时，提醒他们需要额外安装，提供了更友好的报错信息。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'json'</span>,</span><br><span class="line">  <span class="string">'urlencoded'</span>,</span><br><span class="line">  <span class="string">'bodyParser'</span>,</span><br><span class="line">  <span class="string">'compress'</span>,</span><br><span class="line">  <span class="string">'cookieSession'</span>,</span><br><span class="line">  <span class="string">'session'</span>,</span><br><span class="line">  <span class="string">'logger'</span>,</span><br><span class="line">  <span class="string">'cookieParser'</span>,</span><br><span class="line">  <span class="string">'favicon'</span>,</span><br><span class="line">  <span class="string">'responseTime'</span>,</span><br><span class="line">  <span class="string">'errorHandler'</span>,</span><br><span class="line">  <span class="string">'timeout'</span>,</span><br><span class="line">  <span class="string">'methodOverride'</span>,</span><br><span class="line">  <span class="string">'vhost'</span>,</span><br><span class="line">  <span class="string">'csrf'</span>,</span><br><span class="line">  <span class="string">'directory'</span>,</span><br><span class="line">  <span class="string">'limit'</span>,</span><br><span class="line">  <span class="string">'multipart'</span>,</span><br><span class="line">  <span class="string">'staticCache'</span>,</span><br><span class="line">].forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(exports, name, &#123;</span><br><span class="line">    get         : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Most middleware (like '</span> + name + <span class="string">') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-应用-application-js"><a href="#3-应用-application-js" class="headerlink" title="3 应用 application.js"></a>3 应用 <code>application.js</code></h3><h4 id="初始化-app-defaultConfiguration"><a href="#初始化-app-defaultConfiguration" class="headerlink" title="初始化 app.defaultConfiguration"></a>初始化 <code>app.defaultConfiguration</code></h4><ol>
<li><p>虽然在 <code>createApplication</code> 中调用的是app.init()，但查看 <code>application.js</code> 的init就会发现，init只是在初始化应用之前为一些属性赋了空值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - setup default configuration</span></span><br><span class="line"><span class="comment"> *   - setup default middleware</span></span><br><span class="line"><span class="comment"> *   - setup route reflection methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.engines = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.settings = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 调用真正的初始化方法</span></span><br><span class="line">  <span class="keyword">this</span>.defaultConfiguration();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultConfiguration解析。</p>
<blockquote>
<p>在这里单步执行，可以直观查看所有默认默认信息。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize application configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.defaultConfiguration = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化app的默认配置</span></span><br><span class="line">  <span class="keyword">let</span> env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default settings</span></span><br><span class="line">  <span class="keyword">this</span>.enable(<span class="string">'x-powered-by'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'etag'</span>, <span class="string">'weak'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'env'</span>, env);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'query parser'</span>, <span class="string">'extended'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'subdomain offset'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'trust proxy'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.settings, trustProxyDefaultSymbol, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value       : <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">'booting in %s mode'</span>, env);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听 mount 事件：当向express添加中间件时就会触发</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onmount</span>(<span class="params">parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// inherit trust proxy</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.settings[trustProxyDefaultSymbol] === <span class="literal">true</span></span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> parent.settings[<span class="string">'trust proxy fn'</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.settings[<span class="string">'trust proxy'</span>];</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.settings[<span class="string">'trust proxy fn'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inherit protos</span></span><br><span class="line">    <span class="comment">// 将每个中间件的request, response, engine, settings对象的__proto__形成原型链</span></span><br><span class="line">    <span class="comment">// 最顶层的request, response对象是Node原生的request和response对象，在createApplication中定义</span></span><br><span class="line">    <span class="comment">// 源码是: setPrototypeOf(this.request, parent.request); ...</span></span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="keyword">this</span>.request.__proto__ = parent.request.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.response.__proto__ = parent.response.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.engine.__proto__ = parent.engine.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.settings.__proto__ = parent.settings.__proto__;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup locals</span></span><br><span class="line">  <span class="keyword">this</span>.locals = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// top-most app is mounted at /</span></span><br><span class="line">  <span class="keyword">this</span>.mountpath = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default locals</span></span><br><span class="line">  <span class="keyword">this</span>.locals.settings = <span class="keyword">this</span>.settings;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//default configuration</span></span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'view'</span>, View);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'views'</span>, resolve(<span class="string">'views'</span>));</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'jsonp callback name'</span>, <span class="string">'callback'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.enable(<span class="string">'view cache'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'router'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'\'app.router\' is deprecated!\nPlease update your app.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="添加中间件-app-use"><a href="#添加中间件-app-use" class="headerlink" title="添加中间件 app.use"></a>添加中间件 <code>app.use</code></h4><h4 id="渲染视图-app-render"><a href="#渲染视图-app-render" class="headerlink" title="渲染视图 app.render"></a>渲染视图 <code>app.render</code></h4><h3 id="请求扩展-request-js"><a href="#请求扩展-request-js" class="headerlink" title="请求扩展 request.js"></a>请求扩展 <code>request.js</code></h3><h3 id="响应扩展-response-js"><a href="#响应扩展-response-js" class="headerlink" title="响应扩展 response.js"></a>响应扩展 <code>response.js</code></h3><h2 id="关联的其他模块"><a href="#关联的其他模块" class="headerlink" title="关联的其他模块"></a>关联的其他模块</h2><h3 id="merge-descriptors"><a href="#merge-descriptors" class="headerlink" title="merge-descriptors"></a>merge-descriptors</h3><ul>
<li>源码很简单，通过foreach循环，依次将源对象的元素合并给目标对象。没有用到<code>Object.defineProperties</code> ，而是对每个操作符进行判断。<br>如果 <code>redefine</code> (undefined则赋值为true)设置为false并且某一属性目标对象已经包含，则不再进行处理。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge-descriptors 的简化实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">dest, src, redefine</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// check</span></span><br><span class="line">  <span class="keyword">if</span> (!dest || !src) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'dest or src is required'</span>);</span><br><span class="line">  <span class="keyword">if</span> (redefine === <span class="literal">undefined</span>) redefine = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(src).forEach(<span class="function"><span class="keyword">function</span> <span class="title">forEachOwnPropertyName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// skip</span></span><br><span class="line">    <span class="keyword">if</span> (!redefine &amp;&amp; hasOwnProperty.call(dest, name)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(src, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(dest, name, descriptor);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      新坑，基于 Express@4.15.3 的源码分析，慢慢填
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Express" scheme="https://claude-ray.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建过程</title>
    <link href="https://claude-ray.github.io/2017/06/18/Hexo%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>https://claude-ray.github.io/2017/06/18/Hexo搭建过程/</id>
    <published>2017-06-18T14:09:28.000Z</published>
    <updated>2017-12-19T14:46:51.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里只列出 hexo 的简明搭建方法，不讲“是什么”和“为什么”，关于 hexo 的更多配置和用法请前往 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Docs</a>  了解。</p>
<h4 id="Node-js-环境"><a href="#Node-js-环境" class="headerlink" title="Node.js 环境"></a>Node.js 环境</h4><p>必须安装Node，方式任选，不多说</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>通过 Node 的 npm 安装 Hexo，命令行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm i -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h4 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt; <span class="comment"># 初始化项目名称 </span></span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt; </span><br><span class="line">$ npm install <span class="comment"># 安装模块</span></span><br></pre></td></tr></table></figure>
<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 必要时，清除上次生成页面时造成的缓存 </span></span><br><span class="line">$ hexo g  <span class="comment"># 生成静态页面 </span></span><br><span class="line">$ hexo s  <span class="comment"># 在本地启动Hexo，可以在浏览器访问 localhost:4000 来预览</span></span><br></pre></td></tr></table></figure>
<h4 id="GitHub-支持"><a href="#GitHub-支持" class="headerlink" title="GitHub 支持"></a>GitHub 支持</h4><p>首先在 GitHub 按照 <code>username.github.io</code> 的格式新建仓库，之后在项目根目录下执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>打开 <code>_config.yml</code> ，编辑 <code>deploy</code>字段，注意替换用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourusername/yourusername.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>配置完成后，只需执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<p>即可将本地内容部署在 GitHub 中，输入域名 <code>username.github.io</code> 进行访问</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><blockquote>
<p>如果不喜欢默认主题，可以参考如下方式更改。</p>
</blockquote>
<p>要把主题更换为Next，先定位到Hexo站点目录进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>之后打开站点配置文件 <code>_config.yml</code>，修改 <code>theme</code> 字段值为 <code>next</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<h4 id="修改Scheme"><a href="#修改Scheme" class="headerlink" title="修改Scheme"></a>修改Scheme</h4><p>Next主题提供了3种Scheme，也决定了外观细节，需要在主题配置文件 <code>themes/next/_config.yml</code> 中进行修改，通过注释和反注释三选一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br></pre></td></tr></table></figure></p>
<h4 id="修改菜单"><a href="#修改菜单" class="headerlink" title="修改菜单"></a>修改菜单</h4><p>在主题配置文件中，找到 <code>menu</code> 字段并进行适当修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  about: /about</span><br><span class="line">  #categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure></p>
<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>同样在主题配置文件中修改 <code>avatar</code> 字段，可以参照注释把avatar图片存在 <code>next/source/images</code> 目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure></p>
<h4 id="阅读统计"><a href="#阅读统计" class="headerlink" title="阅读统计"></a>阅读统计</h4><p>为文章增加字数统计和阅读时长字段，需要安装wordcount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>
<p>最新的2017 next主题已经内置了<code>hexo-wordcount</code>，接下来就可以在主题配置文件<code>_config.yml</code>中，修改如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></p>
<p>关于单篇博客阅读人数的统计，我使用了<code>LeanCloud</code>，而非<code>不蒜子</code>，同样都在next主题中内置。主要原因是<code>不蒜子</code>不能在首页显示阅读统计，此外<code>LeanCloud</code>还提供了一定的管理功能。需要在主题配置文件中修改如下字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: </span><br><span class="line">  app_key:</span><br></pre></td></tr></table></figure>
<h4 id="进阶设定"><a href="#进阶设定" class="headerlink" title="进阶设定"></a>进阶设定</h4><p>官方文档介绍的很详细，请首先查阅<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next使用文档</a></p>
<h3 id="遇到的坑和问题汇总"><a href="#遇到的坑和问题汇总" class="headerlink" title="遇到的坑和问题汇总"></a>遇到的坑和问题汇总</h3><h4 id="404页面配置"><a href="#404页面配置" class="headerlink" title="404页面配置"></a>404页面配置</h4><p>常规的方法是在主题目录即 <code>theme/next/source</code> 下新建 <code>404.html</code> 文件，修改主题配置文件中的<code>commonweal</code>字段，在本地预览404就能看到对应界面。但是，这么配置到GitHub pages就访问不到404页面了。</p>
<blockquote>
<p>网上给出原因是404页面只能绑定顶级域名，如果只用github.io，404页面就失去效果。</p>
</blockquote>
<p>其实，主要原因是Github Pages强制使用https，所以文档内对js和css的请求也都需要经过https才能传输，而腾讯公益404页面默认使用http。<br>所以，只要把出问题的js文件拿到本地进行修改就好了~</p>
<ul>
<li>原本的search_children.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _base = <span class="string">'http://qzone.qq.com/gy/404/'</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="'</span> + _base + <span class="string">'data.js" charset="utf-8"&gt;&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="'</span> + _base + <span class="string">'page.js" charset="utf-8"&gt;&lt;/script&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>初次修改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _base = <span class="string">'https://qzone.qq.com/gy/404/'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制台发现仍然有js文件没有加载进来，阅读 <code>page.js</code> 的代码后明白了，于是 <code>page.js</code> 也拿到本地，修改必要的url为https，终于显示正常了<br>但是有一行貌似没什么用的代码，注释掉了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getData("http://boss.qzone.qq.com/fcg-bin/fcg_zone_info");</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了增强可读性，移除上述js文件，代码直接写入HTML。但出现新问题，返回链接变成默认的腾讯主页了。<br>解决办法是修改 <code>page.js</code> 中如下判断语句条件， <code>search_children.js</code> 改为 <code>data.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (scs[i].src.indexOf(<span class="string">"/404/search_children.js"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageUrl"</span>)) &#123;</span><br><span class="line">    homePageUrl = scs[i].getAttribute(<span class="string">"homePageUrl"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageName"</span>)) &#123;</span><br><span class="line">    homePageName = scs[i].getAttribute(<span class="string">"homePageName"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然页面能正常显示了，但控制台提示提取到的儿童图片url仍然是http，解决这个问题需要在 <code>page.js</code> 中的 <code>resolveData(d)</code> 函数中对数据格式化。<br>在其中的for循环添加一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.data[i].child_pic = d.data[i].child_pic.replace(/^http/, &quot;https&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Finally! 发现了新版的 <code>http://www.qq.com/404/</code> ，logo也更美观了，果断修改。代码再次整洁了，完整如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Claude&apos;s Home - 404&lt;/title&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">        src=&quot;https://qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span><br><span class="line">        charset=&quot;utf-8&quot;</span><br><span class="line">        homePageUrl=&quot;https://claude-ray.github.io/&quot;</span><br><span class="line">        homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>感觉瞎折腾了 XD ！</p>
<h4 id="About页面"><a href="#About页面" class="headerlink" title="About页面"></a>About页面</h4><p>相同主题下，查看他人的 <code>about</code> 页面时，侧栏 <code>sidebar</code> 不会自动弹出，而我的居然会弹出……<br>难道因为 <code>#</code> 标题被当做post了？强迫症下查阅了很多相关文章，还没有发现官方的解决方案，看他们博客的意思是搭建的过程中也仅用了<code>hexo new page about</code>。<br>但回头一想，反正也不难看，就舒舒服服地按 <code>Markdown</code> 的习惯写着吧。</p>
<p>临时解决方案：<br>可以通过在 Markdown 中插入 HTML 标签的方法，移除Markdown的标题判定。</p>
]]></content>
    
    <summary type="html">
    
      使用Hexo打造个人GitHub Pages的简要过程
    
    </summary>
    
      <category term="Hexo" scheme="https://claude-ray.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://claude-ray.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://claude-ray.github.io/2017/06/14/hello-world/"/>
    <id>https://claude-ray.github.io/2017/06/14/hello-world/</id>
    <published>2017-06-13T16:29:04.000Z</published>
    <updated>2017-06-13T16:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
