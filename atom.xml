<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claude&#39;s Home</title>
  <subtitle>Searching</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://claude-ray.github.io/"/>
  <updated>2018-12-12T15:52:41.758Z</updated>
  <id>https://claude-ray.github.io/</id>
  
  <author>
    <name>Claude Ray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>总结node处理GBK编码</title>
    <link href="https://claude-ray.github.io/2018/12/12/node-gbk-sum/"/>
    <id>https://claude-ray.github.io/2018/12/12/node-gbk-sum/</id>
    <published>2018-12-12T14:49:00.000Z</published>
    <updated>2018-12-12T15:52:41.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Node内部不支持直接操作GBK字符串，而实际也并不需要如此。</p>
<p>总的原则是，gbk的逻辑仅保留在输入和输出，内部处理一律使用utf8。编码转换主要基于<code>iconv-lite</code>库。</p>
<p>总结已经写在了前头，下面再列举几种http服务中常见的处理场景。</p>
<h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><h2 id="请求返回值"><a href="#请求返回值" class="headerlink" title="请求返回值"></a>请求返回值</h2><p>最常用且容易处理，通常我们使用<code>request</code>发起http请求，options中设置<code>encoding: null</code>，这样返回的res.body为buffer，再对buffer进行解码<code>iconv.decode(res.body, encoding)</code>。</p>
<blockquote>
<p>引用：<a href="https://claude-ray.github.io/2018/02/26/request%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/#%E7%BC%96%E7%A0%81">request返回值中文乱码问题</a></p>
</blockquote>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>这里直接用<code>iconv-lite</code>处理略显复杂，建议上<a href="https://github.com/node-modules/urlencode" target="_blank" rel="noopener">urlencode</a>。</p>
<p>post请求时stringify整个body对象，用options.form提交。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlencode.stringify(body, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>querystring则stringify后再拼到url中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlencode.stringify(qs, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="接口返回值"><a href="#接口返回值" class="headerlink" title="接口返回值"></a>接口返回值</h2><p>以koa举例，返回值先使用<code>iconv-lite</code>转为gbk Buffer，随后设置响应头的content-type。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.body = iconv.encode(<span class="string">'你好'</span>, <span class="string">'gbk'</span>);</span><br><span class="line">ctx.type = <span class="string">'text/plain; charset=gbk'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口参数"><a href="#接口参数" class="headerlink" title="接口参数"></a>接口参数</h2><p>同样以koa举例，结合koa-bodyparser，原始参数分别在ctx.request.rawBody和ctx.request.querystring中，<code>urlencode.parse</code>解析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urlencode.parse(ctx.request.rawBody, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br><span class="line">urlencode.parse(ctx.request.querystring, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果能约定使用十六进制传参更好，处理hex就不需要在参数获取上额外处理了。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>默认方式（<code>encoding: null</code>）就是操作buffer，iconv转换无压力。</p>
<p>读：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buff = fs.readFileSync(<span class="string">'test.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iconv.decode(buff, <span class="string">'gbk'</span>));</span><br></pre></td></tr></table></figure></p>
<p>写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buff = iconv.encode(<span class="string">'你好'</span>, <span class="string">'gbk'</span>);</span><br><span class="line">fs.writeFileSync(<span class="string">'test.txt'</span>, buff);</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Node内部不支持直接操作GBK字符串，而实际也并不需要如此。&lt;/p&gt;
&lt;p&gt;总的原则是，gbk的逻辑仅保留在输入和输出，内部处理一律使用u
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="String" scheme="https://claude-ray.github.io/tags/String/"/>
    
      <category term="GBK编码" scheme="https://claude-ray.github.io/tags/GBK%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置ss-local客户端</title>
    <link href="https://claude-ray.github.io/2018/12/01/ss-local/"/>
    <id>https://claude-ray.github.io/2018/12/01/ss-local/</id>
    <published>2018-12-01T14:03:28.000Z</published>
    <updated>2018-12-02T07:38:29.788Z</updated>
    
    <content type="html"><![CDATA[<p>ss-local是<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a>提供的客户端工具，若想正常使用需先准备一台机器部署shadowsocks服务端以作为代理。</p>
<h2 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h2><p>Ubuntu 16以上直接用apt安装，其他发行版可以查阅文档<a href="https://github.com/shadowsocks/shadowsocks-libev#installation" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev#installation</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure></p>
<h2 id="二、编辑配置文件"><a href="#二、编辑配置文件" class="headerlink" title="二、编辑配置文件"></a>二、编辑配置文件</h2><h3 id="配置代理服地址"><a href="#配置代理服地址" class="headerlink" title="配置代理服地址"></a>配置代理服地址</h3><p>参考config.json修改local.json，填写代理服务器的地址。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/shadowsocks-libev/config.json /etc/shadowsocks-libev/local.json</span><br><span class="line">sudo vi /etc/shadowsocks-libev/local.json</span><br></pre></td></tr></table></figure></p>
<p>建议<code>local_port</code>不要使用默认的1080，例如改为1081。主要是避免和ss-server（在安装后默认作为<code>shadowsocks-libev.service</code>启动）抢占端口，或者选择手动停掉ss-server。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: <span class="string">"代理服地址"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>: <span class="string">"代理服端口"</span>,</span><br><span class="line">  <span class="attr">"local_port"</span>: <span class="number">1081</span>,</span><br><span class="line">  <span class="attr">"password"</span>: <span class="string">"代理服密码"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>: <span class="number">60</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"chacha20-ietf-poly1305"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="配置systemd-service"><a href="#配置systemd-service" class="headerlink" title="配置systemd service"></a>配置systemd service</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /lib/systemd/system/shadowsocks-libev-local@.service</span><br></pre></td></tr></table></figure>
<p>替换其中ExecStart的配置路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/ss-local -c /etc/shadowsocks-libev/local.json</span><br></pre></td></tr></table></figure></p>
<h2 id="三、启动服务"><a href="#三、启动服务" class="headerlink" title="三、启动服务"></a>三、启动服务</h2><p>使用systemctl或service管理服务<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">sudo systemctl start shadowsocks-libev-local@.</span><br><span class="line"><span class="comment">#或 $ sudo service shadowsocks-libev-local@.service start</span></span><br><span class="line"><span class="comment">#查看运行情况</span></span><br><span class="line">sudo systemctl status shadowsocks-libev-local@.</span><br><span class="line"><span class="comment">#配置开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks-libev-local@.</span><br></pre></td></tr></table></figure></p>
<h2 id="四、配置PAC文件"><a href="#四、配置PAC文件" class="headerlink" title="四、配置PAC文件"></a>四、配置PAC文件</h2><p>PAC的语法是js，规则非常简单。核心点是实现<code>FindProxyForURL</code>函数，判断当前域名是否使用代理，不需要代理的域名直接返回<code>DIRECT</code>。</p>
<p>因此内容自己实现就可以，但不支持es6及以上特定，这里参考<a href="https://github.com/JinnLynn/genpac" target="_blank" rel="noopener">genpac</a>加上endsWith的polyfill。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 端口号按之前配置local.json的local_port来填写，默认1080</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="string">'SOCKS5 127.0.0.1:1081'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走代理的host</span></span><br><span class="line"><span class="keyword">var</span> hosts = [</span><br><span class="line">  <span class="string">'evernote.com'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hosts.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (host.endsWith(hosts[i])) <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * REF:</span></span><br><span class="line"><span class="comment"> * genpac 2.1.0</span></span><br><span class="line"><span class="comment"> * https://github.com/JinnLynn/genpac</span></span><br><span class="line"><span class="comment"> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.endsWith) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.endsWith = <span class="function"><span class="keyword">function</span>(<span class="params">searchString, position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subjectString = <span class="keyword">this</span>.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> position !== <span class="string">'number'</span> || !<span class="built_in">isFinite</span>(position) || <span class="built_in">Math</span>.floor(position) !== position || position &gt; subjectString.length) &#123;</span><br><span class="line">        position = subjectString.length;</span><br><span class="line">    &#125;</span><br><span class="line">    position -= searchString.length;</span><br><span class="line">    <span class="keyword">var</span> lastIndex = subjectString.indexOf(searchString, position);</span><br><span class="line">    <span class="keyword">return</span> lastIndex !== <span class="number">-1</span> &amp;&amp; lastIndex === position;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、配置系统代理"><a href="#五、配置系统代理" class="headerlink" title="五、配置系统代理"></a>五、配置系统代理</h2><p>这一步可以通过export来设置，但没找到automatic的配置方法，干脆用系统自带的proxy来处理。按如下步骤一路点，最后填上PAC文件的路径。</p>
<p>Network -&gt; Network proxy -&gt; Automatic -&gt; Configuration URL -&gt; <code>/etc/proxy/my.pac</code></p>
]]></content>
    
    <summary type="html">
    
      近期Evernote因为局域网问题不能使用了，作为重要工具不能离手，于是借助ss代理方式应急一下。ubuntu18没有特别好用的ss GUI，故选择了命令行工具ss-local。部署没难度，操作流程是翻文档加自己探索，个人认为比网上其他攻略简单，分享出来希望有助于大家解决网络疑难杂症。同时声明，本文只涉及客户端部署，evernote.com截止文章发布时间并没有被墙，请使用国内云服务器代理合规站点。
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://claude-ray.github.io/tags/Ubuntu/"/>
    
      <category term="proxy" scheme="https://claude-ray.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Jest共享server和tests的上下文环境</title>
    <link href="https://claude-ray.github.io/2018/10/30/jest-server-context/"/>
    <id>https://claude-ray.github.io/2018/10/30/jest-server-context/</id>
    <published>2018-10-30T14:05:19.000Z</published>
    <updated>2018-10-31T14:14:29.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>单元测试，test文件的加载顺序尤为关键。对于服务端，通常先启动http server，再通过发起接口请求的方式展开后续测试。</p>
<p>但仅仅controller层测试不能满足复杂业务的校验，需要对service及以下层级编写测试时，需要切入server的上下文环境才能做出恰当处理。</p>
<p>笔者尝试一番发现Jest并不能优雅地使用配置支持node.js server和test cases共享上下文环境，具体情况将在下文交代。</p>
<h1 id="Jest配置项说明"><a href="#Jest配置项说明" class="headerlink" title="Jest配置项说明"></a>Jest配置项说明</h1><p>jest倾向于将测试执行前的运行环境都加载配置(package.json的jest)中。因此我也先在官网<a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">文档</a>中查询了相关配置项。</p>
<h2 id="globalSetup-string"><a href="#globalSetup-string" class="headerlink" title="globalSetup [string]"></a>globalSetup [string]</h2><blockquote>
<p>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest’s globalConfig object as a parameter.</p>
</blockquote>
<p>通过字符串指定一个文件，其exports的函数作为初始化脚本，并支持异步操作。</p>
<p>jest运行测试过程中，此函数只会在所有测试用例加载前执行一次。用途可以是执行安装脚本，初始化数据库等。</p>
<p>需要特别注意的是，此函数运行的上下文环境与接下来的测试用例并无关联。</p>
<blockquote>
<p>详见issue <a href="https://github.com/facebook/jest/issues/6007" target="_blank" rel="noopener">https://github.com/facebook/jest/issues/6007</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/setup.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这个变量并不会传到test case中</span></span><br><span class="line">  global.setup = <span class="string">'setup'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="globalTeardown-string"><a href="#globalTeardown-string" class="headerlink" title="globalTeardown [string]"></a>globalTeardown [string]</h2><blockquote>
<p>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest’s globalConfig object as a parameter.</p>
</blockquote>
<p>同globalSetup，该异步函数只会在整个测试生命周期末执行一次。用途可以是运行环境重置，还原或drop数据库等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/teardown.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`这里和<span class="subst">$&#123;global.setup&#125;</span>运行环境一致`</span>);</span><br><span class="line">  <span class="keyword">return</span> process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="testEnvironment-string"><a href="#testEnvironment-string" class="headerlink" title="testEnvironment [string]"></a>testEnvironment [string]</h2><p>通常是指定运行环境，默认浏览器，nodejs需要指定为<code>node</code>。</p>
<p>当然也可以指定为一个文件。该文件需要继承自<code>jest-environment-node</code>，并实现<code>setup</code>、<code>teardown</code>和<code>runScript</code>三个方法。</p>
<p>以官文的demo举例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/env.js</span></span><br><span class="line"><span class="keyword">const</span> NodeEnvironment = <span class="built_in">require</span>(<span class="string">'jest-environment-node'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEnvironment</span> <span class="keyword">extends</span> <span class="title">NodeEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(config) &#123;</span><br><span class="line">    <span class="keyword">super</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> setup() &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">super</span>.setup();</span><br><span class="line">    <span class="keyword">await</span> someSetupTasks();</span><br><span class="line">    <span class="keyword">this</span>.global.someGlobalObject = createGlobalObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> teardown() &#123;</span><br><span class="line">    <span class="keyword">this</span>.global.someGlobalObject = destroyGlobalObject();</span><br><span class="line">    <span class="keyword">await</span> someTeardownTasks();</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">super</span>.teardown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  runScript(script) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.runScript(script);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CustomEnvironment;</span><br></pre></td></tr></table></figure></p>
<p>这里上下文环境支持通过<code>this.global</code>将变量共享到每个测试文件。</p>
<p><code>jest-environment-node</code>方法说明：</p>
<ul>
<li><p>setup: 每个test suit（通常指测试文件）执行一次，支持异步方法。</p>
</li>
<li><p>teardown: 每个test suit执行一次，支持异步方法。</p>
</li>
<li><p>runScript: 每个小的test都会执行一次，要求用同步，若为异步则执行顺序不可控制。</p>
</li>
</ul>
<h2 id="setupFiles-array"><a href="#setupFiles-array" class="headerlink" title="setupFiles [array]"></a>setupFiles [array]</h2><p>同env的setup。</p>
<h2 id="setupTestFrameworkScriptFile-string"><a href="#setupTestFrameworkScriptFile-string" class="headerlink" title="setupTestFrameworkScriptFile [string]"></a>setupTestFrameworkScriptFile [string]</h2><p>同env的runScript。</p>
<h1 id="Jest生命周期"><a href="#Jest生命周期" class="headerlink" title="Jest生命周期"></a>Jest生命周期</h1><p>了解jest常用的一些启动配置后，应该对加载顺序有了大概的认知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">globaSetup -&gt;</span><br><span class="line"></span><br><span class="line">  2.</span><br><span class="line">  env.setup (every test suit) -&gt;</span><br><span class="line">  env.runScript (every test case) -&gt;</span><br><span class="line">  env.teardown (every test suit) -&gt;</span><br><span class="line"></span><br><span class="line">  3.</span><br><span class="line">  repeat...</span><br><span class="line"></span><br><span class="line">    n.</span><br><span class="line">    -&gt; globalTeardown</span><br></pre></td></tr></table></figure>
<h1 id="Context共享"><a href="#Context共享" class="headerlink" title="Context共享"></a>Context共享</h1><h2 id="调整Server启动位置"><a href="#调整Server启动位置" class="headerlink" title="调整Server启动位置"></a>调整Server启动位置</h2><p>根据不同的测试场景，选择合适的server启动位置：</p>
<ol>
<li><p>仅接口层测试。对测试代码的加载流程要求最低，只需要保证测试用例执行前启动http服务即可。可以加在jest的任何一环。如无特殊处理，http服务启动一次就好，放在globalSetup为妙。</p>
</li>
<li><p>多层测试，但controller和service之前耦合度较低，用global存储了少量运行信息。这种情况也简单，可以手动挂在this.global，使测试脚本和server的上下文环境相似。</p>
</li>
<li><p>多层测试，各模块耦合严重，上下文挂载了较多内容，不止global中存储的变量，对原生JS对象方法也做了修改。这时，通过jest的配置无法传递上下文。</p>
</li>
</ol>
<p>针对第三种情况，我选择将测试入口限制为单个文件(test suit)，其他测试文件用<code>require()</code>引入。此时，jest的env.setup和setupGlobal效果一致，因为jest认为只是启动了单个测试文件。如下，index.test.js的<code>beforeAll</code>具备了所有测试用例的最高优先级，保证server启动早于测试执行，并实现测试用例和server共享上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/index.test.js</span></span><br><span class="line"></span><br><span class="line">beforeAll(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// launcher server</span></span><br><span class="line">  <span class="keyword">await</span> load();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// require all test files</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./file.test.js'</span>);</span><br></pre></td></tr></table></figure>
<p>综上，总的package.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest ./test/index"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"jest"</span>: &#123;</span><br><span class="line">    <span class="attr">"testEnvironment"</span>: <span class="string">"./test/env.js"</span>,</span><br><span class="line">    <span class="attr">"globalSetup"</span>: <span class="string">"./test/setup.js"</span>,</span><br><span class="line">    <span class="attr">"globalTeardown"</span>: <span class="string">"./test/teardown.js"</span>,</span><br><span class="line">    <span class="attr">"globals"</span>: &#123;</span><br><span class="line">      <span class="attr">"testBoolean"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>参考egg的做法，统一将上下文放在app，并通过<code>egg-mock</code>来获取。</p>
]]></content>
    
    <summary type="html">
    
      本文首先简单介绍Jest关于启动的配置项，阐述Jest测试生命周期，之后粗略总结不同情况的server应该何时启动，最终使用略粗鄙的办法解决本次问题。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="Jest" scheme="https://claude-ray.github.io/tags/Jest/"/>
    
      <category term="Unit Testing" scheme="https://claude-ray.github.io/tags/Unit-Testing/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB升级4.0和事务使用小记</title>
    <link href="https://claude-ray.github.io/2018/10/23/update-mongod4/"/>
    <id>https://claude-ray.github.io/2018/10/23/update-mongod4/</id>
    <published>2018-10-23T14:08:09.000Z</published>
    <updated>2018-10-23T15:54:11.465Z</updated>
    
    <content type="html"><![CDATA[<p>4.0正式版已经出了3个多月，相比测试阶段网上有价值的资料日渐丰富，版本升级以及使用事务需要了解的知识都可以在官网找到。在这里记录一下升级本地开发环境的过程，生产环境应当用数据备份再恢复的方案。</p>
<p>总文档：<a href="https://docs.mongodb.com/manual/release-notes/4.0/" target="_blank" rel="noopener">Release Notes for MongoDB 4.0</a></p>
<h2 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h2><p>单机开发环境，参考<a href="https://docs.mongodb.com/manual/release-notes/4.0-upgrade-standalone/" target="_blank" rel="noopener">standalone升级文档</a></p>
<blockquote>
<p>以下升级流程节选自上述文档</p>
</blockquote>
<p>确保本地是3.6版本才能继续进行，以及兼容版本<code>featureCompatibilityVersion</code>为3.6。在mongo shell中可以执行检查和设置。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.adminCommand( &#123; getParameter: 1, featureCompatibilityVersion: 1 &#125; )</span><br><span class="line"></span><br><span class="line">db.adminCommand( &#123; setFeatureCompatibilityVersion: <span class="string">"3.6"</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>升级前应关闭mongod服务和<strong>备份数据</strong>，之后按照官网所给出对应系统的<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">安装方法</a>执行安装。</p>
<p>例如Ubuntu18，可以按下面依次执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.0 multiverse"</span> | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure></p>
<p>升级完成后在mongo shell中重新设置兼容性<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.adminCommand( &#123; setFeatureCompatibilityVersion: <span class="string">"4.0"</span> &#125; )</span><br></pre></td></tr></table></figure></p>
<h2 id="事务使用"><a href="#事务使用" class="headerlink" title="事务使用"></a>事务使用</h2><h3 id="replSet"><a href="#replSet" class="headerlink" title="replSet"></a>replSet</h3><p>目前必须在replSet中使用，简单的配置方法是<code>/etc/mongod.conf</code>添加设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replication:</span><br><span class="line">  replSetName: rs0</span><br></pre></td></tr></table></figure></p>
<p>然后重启mongod <code>service mongod restart</code>，在mongo shell中执行初始化并查看结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate()</span><br><span class="line">rs.conf()</span><br></pre></td></tr></table></figure></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>官方使用教程，内含demo：<br><a href="https://docs.mongodb.com/manual/core/transactions/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/transactions/</a></p>
<p>Nodejs相关文档（npm包需更新）：</p>
<ul>
<li><p>node-mongodb-native:<br><a href="http://mongodb.github.io/node-mongodb-native/3.1/api/ClientSession.html#startTransaction" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/3.1/api/ClientSession.html#startTransaction</a></p>
</li>
<li><p>mongoose:<br><a href="https://mongoosejs.com/docs/transactions.html" target="_blank" rel="noopener">https://mongoosejs.com/docs/transactions.html</a></p>
</li>
</ul>
<p>手中项目使用事务的场景不多，暂时没有遇到坑，之后遇到再补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;4.0正式版已经出了3个多月，相比测试阶段网上有价值的资料日渐丰富，版本升级以及使用事务需要了解的知识都可以在官网找到。在这里记录一下升级本地开发环境的过程，生产环境应当用数据备份再恢复的方案。&lt;/p&gt;
&lt;p&gt;总文档：&lt;a href=&quot;https://docs.mongod
    
    </summary>
    
      <category term="MongoDB" scheme="https://claude-ray.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://claude-ray.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>koa之Content-Type与Content-Length</title>
    <link href="https://claude-ray.github.io/2018/10/18/koa-content/"/>
    <id>https://claude-ray.github.io/2018/10/18/koa-content/</id>
    <published>2018-10-18T14:16:05.000Z</published>
    <updated>2018-12-11T15:46:17.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h1><p>众所周知，koa可以方便地通过<code>ctx.type=</code>来设置响应头的<code>Content-Type</code>。</p>
<p>但下面这段代码，当响应体ctx.body为<code>object</code>时，无论怎么设置ctx.type，收到的Content-Type都是<code>application/json</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.type = <span class="string">'text/html'</span>;</span><br><span class="line">ctx.body = &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到的content-type依然为application/json</span></span><br></pre></td></tr></table></figure>
<p>为什么设置被覆盖了，要通过一小段koa源码来解释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa/lib/response.js</span></span><br><span class="line"></span><br><span class="line">set body(val) &#123;</span><br><span class="line">  <span class="keyword">const</span> original = <span class="keyword">this</span>._body;</span><br><span class="line">  <span class="keyword">this</span>._body = val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.res.headersSent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// no content</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!statuses.empty[<span class="keyword">this</span>.status]) <span class="keyword">this</span>.status = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">this</span>.remove(<span class="string">'Content-Type'</span>);</span><br><span class="line">    <span class="keyword">this</span>.remove(<span class="string">'Content-Length'</span>);</span><br><span class="line">    <span class="keyword">this</span>.remove(<span class="string">'Transfer-Encoding'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the status</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._explicitStatus) <span class="keyword">this</span>.status = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the content-type only if not yet set</span></span><br><span class="line">  <span class="keyword">const</span> setType = !<span class="keyword">this</span>.header[<span class="string">'content-type'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// string</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setType) <span class="keyword">this</span>.type = <span class="regexp">/^\s*&lt;/</span>.test(val) ? <span class="string">'html'</span> : <span class="string">'text'</span>;</span><br><span class="line">    <span class="keyword">this</span>.length = Buffer.byteLength(val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buffer</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(val)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setType) <span class="keyword">this</span>.type = <span class="string">'bin'</span>;</span><br><span class="line">    <span class="keyword">this</span>.length = val.length;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stream</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> val.pipe) &#123;</span><br><span class="line">    onFinish(<span class="keyword">this</span>.res, destroy.bind(<span class="literal">null</span>, val));</span><br><span class="line">    ensureErrorHandler(val, err =&gt; <span class="keyword">this</span>.ctx.onerror(err));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overwriting</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != original &amp;&amp; original != val) <span class="keyword">this</span>.remove(<span class="string">'Content-Length'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setType) <span class="keyword">this</span>.type = <span class="string">'bin'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// json</span></span><br><span class="line">  <span class="keyword">this</span>.remove(<span class="string">'Content-Length'</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'json'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉koa源码的同学可能还记得，如果ctx.type未设置，会根据传给body的值类型赋予<code>Content-Type</code>默认值。</p>
<ul>
<li><code>null/undefined</code>：type什么的不存在的，即使有也会被删掉，并设置’No Content’ 204状态码</li>
<li><code>string</code>：正则<code>/^\s*&lt;/</code>匹配，分情况设为html或text</li>
<li><code>Buffer</code>：如果未设置type，那么会被改为<code>bin</code>(application/octet-stream)</li>
<li><code>Stream</code>：同Buffer，当然逻辑上会多个绑定结束时destroy和异常处理，如果和旧body不同，还会删掉content-length</li>
<li>以上都不是：即使设置过<code>ctx.type</code>，也会重新标记为json，并删除content-length</li>
</ul>
<p>可想而知，既然已经过每一步判断，body的内容一般就是<code>boolean</code>、<code>object</code>或<code>number</code>之流，标记为<code>json</code>合情合理。当然没忘<code>symbol</code>，它是无法被JSON序列化的，会抛出TypeError。</p>
<p>综上，如果接口返回值满足上述几个json类型，又想更改响应头的content-type，最简单的方法其实是<code>ctx.type=</code>放在<code>ctx.body=</code>之后，以重新覆盖响应头的内容。但一些路由中间件封装的时候没有考虑这层面，把接口返回值作为ctx.body，添加这种在body后设置type的操作可能会遇到困难。</p>
<p>另一种常规方法是调整数据格式后再对ctx.body赋值，例如对object进行JSON.stringify处理后，之前设置的content-type才不会被覆盖为<code>application/json</code>。</p>
<blockquote>
<p>ctx.type的设置支持各类缩略词，每次set前都会通过<code>mime-types</code>和<code>mime-db</code>依赖匹配完整名称，并挂上charset。</p>
</blockquote>
<blockquote>
<p>除了设置，还需要注意的点是ctx.type的getter会过滤掉<code>charset</code>部分，因此<strong>ctx.type的setter和getter不是完全对等的</strong>。如果想获取之前设置过的完整信息，需要通过<code>ctx.res.getHeader(&#39;Content-Type&#39;)</code>到头部获取。</p>
</blockquote>
<p>Wait，好像还漏了什么？</p>
<p>content-type既然在最后给定为json，为什么执行了一个<code>this.remove(&#39;Content-Length&#39;)</code>？且听下面分解。</p>
<h1 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h1><p>在<code>set body</code>的string和Buffer步骤，都会主动判断字节长度（不是字符，所以string用Buffer.byteLength判断），并对this.length即content-length赋值。而json和stream则相反，不但没有设置length，反而把设置过的删掉了。</p>
<p>简单分析一下，stream步骤的删除不难理解，二进制数据流只有传输完毕才能计算长度，不需要从响应头判断length。另一方面，content-length是允许胡乱设置的，koa为了避免它被设置一个错误的值，所以才有了的重新赋值与删除。甚至在异常捕获中也加上了这个fix：<a href="https://github.com/koajs/koa/issues/199" target="_blank" rel="noopener">Content-Length not reset if error is thrown after body is set</a>。</p>
<p>那么json返回值的length被删掉之后，它是从哪里重新被设置呢？</p>
<blockquote>
<p>最初我错想为交给了node底层处理，而且确实在http模块中有对content-length的设置，但它只有在完全未指定headers时才会添加。[<a href="https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js]" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js]</a></p>
</blockquote>
<p>实际对json类型的值判断字节长度非常容易，JSON.stringify加Buffer.byteLength即可。目录内搜索一下对this.length或ctx.length的赋值，果然，在响应的最终res.end()之前看到了该处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa/lib/application.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// responses</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那为什么不在最后一步重新对content-length进行赋值呢？</p>
<p>我的理解是，set body和onerror时完成自动设置已经是仁尽义至了，会在之后主动设置content-length的人未免不是怀有特殊目的，否则开放的<code>ctx.length=</code>功能也毫无用武之地。因此反而能为使用者的发挥留有余地，即使改出了差错也不能怪罪到koa头上。保持目前的写法，恰到好处。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>koa的源码解析文章实在太多了，所以早先没有打算像express那样写一篇逐句分析，而且确实简单易读，<del>恐怕没写完就太监了</del>。但时间一久，很多细节就忘掉了，会遇到此类问题说明对其底层不够熟悉。就此写一篇笔记，发出来加深记忆。[真香.jpg]</p>
]]></content>
    
    <summary type="html">
    
      透过ctx.body setter的执行过程，分析koa如何设置响应头content-type和content-length，以及一些注意事项。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="JavaScript" scheme="https://claude-ray.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="Koa" scheme="https://claude-ray.github.io/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs使用MySQL 4.1的问题解决</title>
    <link href="https://claude-ray.github.io/2018/10/12/old-sms-mas-nodejs/"/>
    <id>https://claude-ray.github.io/2018/10/12/old-sms-mas-nodejs/</id>
    <published>2018-10-12T14:04:17.000Z</published>
    <updated>2018-10-31T14:14:55.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>如果使用<code>old authentication</code>方式连接4.1版本之前的mysql，<code>sequelize</code>和<code>mysql2</code>无法通过认证：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; Error: Access denied <span class="keyword">for</span> user: <span class="string">'@127.0.0.x'</span> (Using password: NO)</span><br><span class="line">    at Packet.asError (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/packets/packet.js:714:13)</span><br><span class="line">    at ClientHandshake.Command.execute (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/commands/command.js:28:22)</span><br><span class="line">    at Connection.handlePacket (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/connection.js:513:28)</span><br><span class="line">    at PacketParser.onPacket (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/connection.js:81:16)</span><br><span class="line">    at PacketParser.executeStart (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/packet_parser.js:76:14)</span><br><span class="line">    at Socket.&lt;anonymous&gt; (/home/claude/Workspace/packages/sql/node_modules/mysql2/lib/connection.js:89:29)</span><br><span class="line">    at Socket.emit (events.js:182:13)</span><br><span class="line">    at addChunk (_stream_readable.js:283:12)</span><br><span class="line">    at readableAddChunk (_stream_readable.js:264:11)</span><br><span class="line">    at Socket.Readable.push (_stream_readable.js:219:10)</span><br><span class="line">    at TCP.onread (net.js:639:20)</span><br><span class="line">  code: <span class="string">'ER_ACCESS_DENIED_ERROR'</span>,</span><br><span class="line">  errno: 1045,</span><br><span class="line">  sqlState: <span class="string">''</span>,</span><br><span class="line">  sqlMessage:</span><br><span class="line">   <span class="string">'Access denied for user: \'</span>@127.0.0.x\<span class="string">' (Using password: NO)'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>处理倒不困难，在不能改动数据库的情况下，可以改用npm包<code>mysql</code>。</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>移动mas的接入文档有描述如下：</p>
<blockquote>
<p>mysql使用ISO8859-1编码，往db接口写入数据时应先把编码格式转化为ISO8859-1…</p>
</blockquote>
<p>上述编码实际为<code>latin1</code>，为早期mysql的默认编码。实际文档存在误导，未指出mas机的db接口是使用gbk编码写入的，因此将字符进行转化gbk再使用该接口即可，无需再将编码转为<code>latin1</code>。</p>
<p>但如果想从数据库中读取，同事在创建连接时指定了<code>charset=latin1</code>获取到的中文是乱码。</p>
<p>这涉及到mysql如何用<code>latin1</code>存储中文的问题：<code>latin1</code>为0x00 to 0xFF范围的单字节编码（<code>ASCII</code>是它的子集），理论上单字节范围可以无损存储数据，任意编码均可以用字节流形式存储。</p>
<p>也就是说，mas机写入之前用的是gbk字节流，读取时直接用nodejs默认的utf8编码自然不行。那么怎样读出二进制数据呢？在npm <code>mysql</code>库的README中搜索<code>buffer</code>字样，找到了如下方法。</p>
<p>mysqljs支持在query中自定义<a href="https://github.com/mysqljs/mysql#string" target="_blank" rel="noopener">typeCast</a>方法，可用于提取数据的步骤进行编码转换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : <span class="string">'localhost'</span>,</span><br><span class="line">  user     : <span class="string">'me'</span>,</span><br><span class="line">  password : <span class="string">'secret'</span>,</span><br><span class="line">  database : <span class="string">'my_db'</span>,</span><br><span class="line">  charset  : <span class="string">'latin1'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">connection.query(&#123;</span><br><span class="line">  sql: <span class="string">'SELECT * FROM tbl_user'</span>,</span><br><span class="line">  typeCast: <span class="function">(<span class="params">field, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// converting `tbl_user.name` to utf8 string:</span></span><br><span class="line">    <span class="keyword">if</span> (field.name === <span class="string">'username'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> iconv.decode(field.buffer(), <span class="string">'gbk'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, (error, results, fields) =&gt; &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中typeCast的参数field包含</p>
<ul>
<li>type 字段类型，<code>VARCHAR</code>等（<a href="https://github.com/mysqljs/mysql/blob/master/lib/protocol/packets/RowDataPacket.js#L41" target="_blank" rel="noopener">详情链接</a>）</li>
<li>name 字段名</li>
<li>length 字段长度</li>
<li>table 表名</li>
<li>db 数据库名</li>
<li>…</li>
</ul>
<p>依此，其他更多问题都可以迎刃而解。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://blog.csdn.net/css_good/article/details/8809016" target="_blank" rel="noopener">mysql中的latin1支持中文</a>，CSDN有很多一样的文章，不清楚谁是原作者。</li>
<li><a href="https://kb.iu.edu/d/ahfr" target="_blank" rel="noopener">What are the differences between ASCII, ISO 8859, and Unicode?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      近期有同学在玩一台老古董服务器，要使用node连上4.1版本的MySQL进行操作。并且不让改动数据库配置，凭啥？人家是移动提供的MAS……本文分享一下帮忙时填的坑，主要为解决“数据库连接”和“编码转换”问题。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="MySQL" scheme="https://claude-ray.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>node图形验证码实现</title>
    <link href="https://claude-ray.github.io/2018/09/02/node-image-captcha/"/>
    <id>https://claude-ray.github.io/2018/09/02/node-image-captcha/</id>
    <published>2018-09-02T13:46:55.000Z</published>
    <updated>2018-10-31T14:12:50.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p>参考文档安装基础图形库，<a href="https://github.com/Automattic/node-canvas" target="_blank" rel="noopener">node-canvas</a>。</p>
<p>建议使用<code>npm install canvas@next</code>安装2.x版本，兼容Windows开发环境，接口功能更完善。</p>
<p>此外，MDN的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D" target="_blank" rel="noopener">canvas相关文档</a>也可以作为重要参考。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><blockquote>
<p><code>opts.*</code>标注的是需要自行完善的属性或方法。图形验证码作为系统安全的一环，就不开放源码了，请谅解。</p>
</blockquote>
<h3 id="1-创建canvas-ctx"><a href="#1-创建canvas-ctx" class="headerlink" title="1. 创建canvas ctx"></a>1. 创建canvas ctx</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="keyword">new</span> Canvas(opts.width, opts.height);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-透明度"><a href="#2-透明度" class="headerlink" title="2. 透明度"></a>2. 透明度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.globalAlpha = opts.opacity;</span><br></pre></td></tr></table></figure>
<h3 id="3-背景色填充"><a href="#3-背景色填充" class="headerlink" title="3. 背景色填充"></a>3. 背景色填充</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = opts.bgc;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, opts.width, opts.height);</span><br></pre></td></tr></table></figure>
<h3 id="4-写字"><a href="#4-写字" class="headerlink" title="4. 写字"></a>4. 写字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; opts.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 字体和随机字号</span></span><br><span class="line">  ctx.font = <span class="string">`<span class="subst">$&#123;opts.fontSize&#125;</span>px <span class="subst">$&#123;opts.font&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 颜色</span></span><br><span class="line">  ctx.fillStyle = opts.randomColor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旋转角度，使用save/restore保存之前填充的状态</span></span><br><span class="line">  ctx.save();</span><br><span class="line">  ctx.rotate(opts.randomAngle());</span><br><span class="line">  <span class="comment">// 填充字体</span></span><br><span class="line">  ctx.fillText(opts.text[i], opts.wordSpaceX, opts.wordSpaceY);</span><br><span class="line">  ctx.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-干扰线"><a href="#5-干扰线" class="headerlink" title="5. 干扰线"></a>5. 干扰线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 干扰线宽度</span></span><br><span class="line">ctx.lineWidth = opts.lineWidth;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">  ctx.strokeStyle = opts.randomColor();</span><br><span class="line">  <span class="comment">// 绘制路径起始点</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  <span class="comment">// 移动画笔</span></span><br><span class="line">  ctx.moveTo(opts.x1, opts.y1));</span><br><span class="line">  ctx.lineTo(opts.x2, opts.y2));</span><br><span class="line">  <span class="comment">// 画线</span></span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-干扰点"><a href="#6-干扰点" class="headerlink" title="6. 干扰点"></a>6. 干扰点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据密度计算个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; opts.pixelNum; i++) &#123;</span><br><span class="line">  ctx.fillStyle = opts.randomColor();</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  <span class="comment">// 用实心圆作为点</span></span><br><span class="line">  ctx.arc(opts.x, opts.y, opts.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的图片产出分多种：<code>Buffer</code>，<code>DataUrl</code>和<code>Stream</code>，就从官方文档上看例子吧，注意1.x和2.x的版本差异。</p>
<h2 id="应急方案"><a href="#应急方案" class="headerlink" title="应急方案"></a>应急方案</h2><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p>挑选一些对人眼友好的颜色，随机筛选几个拼接成渐变色背景，可以略微提高识别成本。但对于成熟的破解算法无意义，如果和字体颜色过接近，用户识别也会特别痛苦。</p>
<p>举个简单的3段式，抛砖引玉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gradient = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, opts.width, opts.height);</span><br><span class="line"></span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, opts.randomBGC());</span><br><span class="line">gradient.addColorStop(<span class="number">0.5</span>, opts.randomBGC());</span><br><span class="line">gradient.addColorStop(<span class="number">1</span>, opts.randomBGC());</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = gradient;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, opts.width, opts.height);</span><br></pre></td></tr></table></figure></p>
<h3 id="空心字体"><a href="#空心字体" class="headerlink" title="空心字体"></a>空心字体</h3><p>canvas原生支持的几个字体差别实在不大，有个技巧是绘制空心字体，在验证码被攻击时，可以加入支持应急，在攻击者没有准备的情况下，可以立刻起到拦截效果。</p>
<p>用法很简单，将上面写字用到的<code>fillStyle</code>替换为<code>strokeStyle</code>，<code>fillText</code>替换为<code>strokeText</code>。</p>
<h2 id="Lib选择"><a href="#Lib选择" class="headerlink" title="Lib选择"></a>Lib选择</h2><p>起初，使用<code>gm</code>和<code>GraphicsMagick</code>的组合，但经压测发现了严重的性能问题，在<a href="https://stackoverflow.com/questions/23795669/graphicsmagick-for-node-js-gm-module-performance" target="_blank" rel="noopener">StackOverFlow</a>上也看到了原因，于是决定更换绘图方案。</p>
<blockquote>
<p>The gm module calls out to a command-line tool. You might look at using graphicsmagick2 instead, which is an actual binding to the graphicsmagick library. Unfortunately there is no documentation, so you’ll have to read the source for that (which isn’t too long).</p>
</blockquote>
<p>测试了npm上几个热门验证码模块，有两种相对高效的实现</p>
<ol>
<li>c++调用canvas运行环境（node-canvas）</li>
<li>无外部依赖，纯js绘图（trek-captcha）</li>
</ol>
<p>两年以上没人维护的包没有进行测试，有个自称1200/s的ccap，按我的需求出图，效率不及上面的一半。</p>
<p>最终选择了性能出色的node-canvas。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上用法是作者半年前尝试推行AI验证无果的无奈产物，终于在近期被大举攻破时宣告灭亡。</p>
<p>在AI面前，图形验证码的防御力是非常低的，建议处理验证码业务的各位趁早接入行为识别。</p>
<p>希望可以帮到有需要的同学。</p>
<p>Last but not least，附两篇他人的精彩调研：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/c63b78a373ad" target="_blank" rel="noopener">验证码WEB端产品调研（一）：Google reCAPTCHA</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/c64902f60c7c" target="_blank" rel="noopener">验证码WEB端产品调研（二）：极限验证</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      JS的图形验证码已有很多开源实现，可以直接用npm引入，但如果综合考虑性能和契合度时，还是亲自动手造一个好。当然实现起来并不复杂，且方便结合自身需求调整，在此分享一下使用node-canvas绘制验证码的几个心得。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="JavaScript" scheme="https://claude-ray.github.io/tags/JavaScript/"/>
    
      <category term="Captcha" scheme="https://claude-ray.github.io/tags/Captcha/"/>
    
      <category term="Canvas" scheme="https://claude-ray.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04升级18.04LTS</title>
    <link href="https://claude-ray.github.io/2018/08/23/ubuntu16to18md/"/>
    <id>https://claude-ray.github.io/2018/08/23/ubuntu16to18md/</id>
    <published>2018-08-23T13:16:15.000Z</published>
    <updated>2018-10-08T14:11:40.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="进度缓慢"><a href="#进度缓慢" class="headerlink" title="- 进度缓慢"></a>- 进度缓慢</h3><p>部分软件需要手动输入y/n来决定一些新旧配置项的取舍，长时间不去查看就会一直卡着。</p>
<h3 id="桌面崩溃"><a href="#桌面崩溃" class="headerlink" title="- 桌面崩溃"></a>- 桌面崩溃</h3><p>由于加了一些界面美化插件，非常担心桌面崩溃，果然更新了三分之一就跪了。</p>
<p>尝试注销桌面系统，过一会儿屏幕上只剩一个鼠标，凉凉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill Xorg</span><br></pre></td></tr></table></figure></p>
<p>为了恢复工作，尝试重新安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall ubuntu.desktop</span><br></pre></td></tr></table></figure></p>
<p>但提示<code>Could not get lock /var/lib/dpkg/lock</code>，尝试强制获取lock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br></pre></td></tr></table></figure></p>
<p>这时再执行reinstall ubuntu.desktop时，提示需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure -a</span><br></pre></td></tr></table></figure></p>
<p>电脑硬盘不好，漫长的等待。此时一边在命令行工作，一边，等到上面指令终于执行完毕，基本上心态已崩，揣着重装系统的念头，(此时一定要做好数据备份)。</p>
<p>继续尝试重启<code>shutdown now -r</code>无效，按提示<code>systemctl reboot -i</code>成功启动</p>
<h2 id="善后"><a href="#善后" class="headerlink" title="善后"></a>善后</h2><p>惊喜是一次重启就成功了，部分软件如redshift提示无法使用，原因是缺了一些依赖，重新下载即可。</p>
<p>但是打开浏览器发现无法上网，但系统提示网线已连接，第一反应是dns，修改了<code>/etc/resolv.conf</code>没效果，又习惯性用ssh测远程连接，再次失败陷入误区。当发现使用ip和端口可以访问服务时才彻底意识到是dns的问题。</p>
<h3 id="修改dns"><a href="#修改dns" class="headerlink" title="- 修改dns"></a>- 修改dns</h3><p>一般情况，使用DHCP就可以动态处理网络问题。当有修改必要时，需要注意新旧版本Ubuntu修改方式存在差异。</p>
<h4 id="16-04以下："><a href="#16-04以下：" class="headerlink" title="16.04以下："></a>16.04以下：</h4><p>旧版本的ubuntu修改dns有两种方式，并不包含直接修改<code>/etc/resolv.conf</code>。</p>
<p>编辑<code>/etc/resolvconf/resolv.conf.d/base</code>，文件初始内容为空，加上<code>nameserver 8.8.8.8</code>，之后需执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure></p>
<p>才会正确生效并写入<code>/etc/resolv.conf</code>。</p>
<p>另一种方式是直接修改<code>/etc/network/interfaces</code>。</p>
<h4 id="18-04："><a href="#18-04：" class="headerlink" title="18.04："></a>18.04：</h4><p>以上方法均不适用，因为Ubuntu18采用了<code>Netplan</code>，查看DNS配置应使用<code>systemd-resolve --status</code>，</p>
<p>可以停用<code>systemd-resolved</code>服务但不推荐，目前修改教程较少，之后会越来越多。（<a href="https://www.itzgeek.com/how-tos/linux/ubuntu-how-tos/netplan-how-to-configure-static-ip-address-in-ubuntu-18-04-using-netplan.html" target="_blank" rel="noopener">参考链接</a>）</p>
<h3 id="修复ssh"><a href="#修复ssh" class="headerlink" title="- 修复ssh"></a>- 修复ssh</h3><p>升级之后使用ssh提示<code>permission denied (publickey)</code>，最快排查办法是带上参数<code>-vvv</code>，我这里的错误是未指定私钥文件，使用<code>-i</code>加私钥路径可解。</p>
<p>当然不想每次都-i，因此可以将公钥私钥放在id_rsa，id_rsa.pub。同时不想每次都输入密码，执行<code>ssh-add ~/.ssh/id_dsa</code>。</p>
<p>注意密钥权限只能属于使用者，文件400权限就好，超过权限范围会提示Permissions too open。</p>
<h3 id="18-04部署攻略"><a href="#18-04部署攻略" class="headerlink" title="- 18.04部署攻略"></a>- 18.04部署攻略</h3><p>重装redshift时发现有人整理了一些安装指令，可以方便大家部署新系统。</p>
<p><a href="https://github.com/erikdubois/Ultimate-Ubuntu-18.04" target="_blank" rel="noopener">https://github.com/erikdubois/Ultimate-Ubuntu-18.04</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于桌面系统相当脆弱，一定要通过命令行来完成升级，也方便处理异常。出现问题升级不一定中断，不要急着重启，避免让问题严重到系统无法访问。</p>
<p>不要听信网上的无痛升级论，做好数据备份，谨慎操作。</p>
<h3 id="16-08-24更新"><a href="#16-08-24更新" class="headerlink" title="16-08-24更新"></a>16-08-24更新</h3><p>桌面系统再次崩溃，详情可以看这个<a href="https://bugs.launchpad.net/ubuntu/+source/gdm3/+bug/1779476" target="_blank" rel="noopener">Bug</a>，并且在论坛找到了非常相似的<a href="https://ubuntuforums.org/showthread.php?t=2391542" target="_blank" rel="noopener">遭遇</a>。</p>
<p>起初还不清楚是什么状况，试过了swapoff，gnome重装，gdm3降级，切换lightdm等等，看到bug反馈时终于决定接受了各位前人的重装解决方案。</p>
<p>顺便碰到了双系统不能上网问题，修复较容易，BIOS 关闭<code>wake on lan</code>，如果已经关闭就重新打开再关闭。</p>
]]></content>
    
    <summary type="html">
    
      上个月第一次收到升级推送，当时工作较重又担心出现问题就拒绝了。今天又收到推送，恰好本地没有怕丢的代码，但是经验不足，直接通过推送窗口点击了同意，接下来虚惊一场。次日，桌面系统再次崩溃，强烈建议不要升级而是彻底重装!
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://claude-ray.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>阿里云验证码node接入</title>
    <link href="https://claude-ray.github.io/2018/07/31/%E9%98%BF%E9%87%8C%E4%BA%91%E9%AA%8C%E8%AF%81%E7%A0%81node%E6%8E%A5%E5%85%A5/"/>
    <id>https://claude-ray.github.io/2018/07/31/阿里云验证码node接入/</id>
    <published>2018-07-31T14:51:14.000Z</published>
    <updated>2018-10-31T14:16:55.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h2><p>首先放出<del>不是那么</del>重要的文档地址。</p>
<p>我认为值得看的是使用说明中的流程图，其他感兴趣的信息可以在文档左侧菜单查找。</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66306.html" target="_blank" rel="noopener">滑动验证使用说明</a></li>
<li><a href="https://help.aliyun.com/document_detail/66349.html" target="_blank" rel="noopener">签名机制</a></li>
<li><a href="https://develop.aliyun.com/tools/sdk" target="_blank" rel="noopener">阿里云全部SDK</a></li>
</ul>
<p>明明很重要的参数说明，太坑了，看不看都一样。</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66340.html" target="_blank" rel="noopener">验证码服务端API</a></li>
<li><a href="https://help.aliyun.com/document_detail/66348.html" target="_blank" rel="noopener">公共参数</a></li>
</ul>
<h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><p>不得不说接入过程比geetest痛苦多了，后续会上传相关代码以供参考。关键是阿里云验证码版本号太多，我不想维护一个非官方SDK，因此也不会发布npm。</p>
<h3 id="1-阿里云控制台"><a href="#1-阿里云控制台" class="headerlink" title="1. 阿里云控制台"></a>1. 阿里云控制台</h3><ul>
<li>添加用户，拿到<code>AccessKeyID</code>和<code>AccessKeySecret</code></li>
<li>在<code>安全</code>-&gt;<code>数据风控</code>配置验证码，拿到<code>AppKey</code>，同时可获取接入demo。(虽然配置时要选择使用场景，而且只能靠单选生成一个<code>original scene</code>，实际使用时<code>Scene</code>参数可以自定义传递。)</li>
</ul>
<h3 id="2-下载其他版本SDK"><a href="#2-下载其他版本SDK" class="headerlink" title="2. 下载其他版本SDK"></a>2. 下载其他版本SDK</h3><p>很有必要，踩的坑全靠这一步来填。这里选择了php版sdk，前面提到阿里文档的参数并不准确，重点看以下文件补全参数。</p>
<ul>
<li><code>aliyun-php-sdk-afs/afs/Request/V20180112/AuthenticateSigRequest.php</code></li>
<li><code>aliyun-php-sdk-core/RpcAcsRequest.php</code></li>
</ul>
<h3 id="3-计算签名"><a href="#3-计算签名" class="headerlink" title="3. 计算签名"></a>3. 计算签名</h3><p>官方文档还算详细，更方便的是直接参考阿里云node-sdk的开源实现，如<code>https://github.com/willin/waliyun</code>。</p>
<blockquote>
<p>请求方式的不同，会决定signature是否需要经过编码。</p>
</blockquote>
<h3 id="4-HTTPS请求"><a href="#4-HTTPS请求" class="headerlink" title="4. HTTPS请求"></a>4. HTTPS请求</h3><p>GET和POST都支持，只需留意签名计算的区别。<br>为了避免各种请求模块对参数的编码进行再次转换，省心的做法是拼接完整url后使用GET请求。</p>
<h3 id="5-付费模式"><a href="#5-付费模式" class="headerlink" title="5. 付费模式"></a>5. 付费模式</h3><p>友情提示一下，官网明说<code>免费调用周期7天</code>，结果试用两天就收到0.08元欠费通知，找了半天没看到扣费明细，心塞T_T</p>
<p>应该是直接进入了后付费模式，因此测试时请做好心理准备。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不可轻信文档，特别是神奇的日期格式版本号Version，公共参数居然给定了取值<code>2016-11-23</code>，但没给验证地址。</p>
<p>事实上新旧Version的验证地址并不相同。在不知情时用错误地址进行校验，一直提示InvalidVersion，并且没有对应的错误返回值文档。</p>
<p>除了验证地址，不同Version下需要提交的必选参数也不同，详情需要去其他版本SDK挖掘。</p>
<p>看得出文档内容比前人吐槽的时候丰富了不少，望相关开发人员及时更新。</p>
<h3 id="SDK实现"><a href="#SDK实现" class="headerlink" title="SDK实现"></a>SDK实现</h3><p><a href="https://github.com/Claude-Ray/aliyun-captcha" target="_blank" rel="noopener">aliyun-captcha</a></p>
]]></content>
    
    <summary type="html">
    
      分享接入过程和心得
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="Captcha" scheme="https://claude-ray.github.io/tags/Captcha/"/>
    
  </entry>
  
  <entry>
    <title>解决svn没有merge全部更改的问题</title>
    <link href="https://claude-ray.github.io/2018/03/19/%E8%A7%A3%E5%86%B3svn%E6%B2%A1%E6%9C%89merge%E5%85%A8%E9%83%A8%E6%9B%B4%E6%94%B9%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://claude-ray.github.io/2018/03/19/解决svn没有merge全部更改的问题/</id>
    <published>2018-03-19T03:53:52.000Z</published>
    <updated>2018-03-19T16:59:53.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天使用svn合并主干到发布分支时，发现即使没有冲突，也出现了文件错误。检查后发现，文件内有一部分历史更改被遗漏了。</p>
<p>准确的说，上一次合并开发分支到主干后，由于只想发布个别文件（individual files），在发布分支merge拉取后只选择性的commit了4个文件，其他的文件（并非首次创建）更改自此忽略。记本次为操作A。</p>
<p>正常情况下，重新执行merge，仍然可以看到未提交的改动文件，但本次merge隔操作A数个版本之后，<code>mergeinfo</code>也并不会显示操作A漏掉的提交。</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="1-ignore-ancestry"><a href="#1-ignore-ancestry" class="headerlink" title="1. ignore ancestry"></a>1. ignore ancestry</h3><p>除了操作A之外，也有很多其他只提交特定文件的merge记录，所以直接加<code>--ignore-ancestry</code>，甚至出现了以下错误导致无法合并。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn: E200004: Cannot merge automatically <span class="keyword">while</span> ignoring mergeinfo</span><br></pre></td></tr></table></figure></p>
<h3 id="2-指定版本号"><a href="#2-指定版本号" class="headerlink" title="2. 指定版本号"></a>2. 指定版本号</h3><p>指定被漏掉更改的那个版本号（例如r233），可以只找回当时漏提交的文件(使用参数<code>-c</code>, 限定ARG-1:ARG的修改)。</p>
<p>完整命令如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge --ignore-ancestry -c 233 http://localhost/svn/url</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>笔者对svn使用仍不够熟练，一直使用命令行操作，可能这也是触发霉头的根源。 XD</p>
<p>粗略浏览了Stack Overflow，没看到期望的答案，但有些回答也给我一些启发，捡一条附在了下面。</p>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p><a href="https://stackoverflow.com/questions/754082/merging-across-branches-in-subversion-isnt-adding-all-the-new-files-why-not" target="_blank" rel="noopener">Merging across branches in Subversion isn’t adding all the new files. Why not?
</a></p>
<p>The following statement is not true:</p>
<blockquote>
<p>Files that were added to a branch and then changed on the branch don’t get added when doing a merge across number of revisions</p>
</blockquote>
<p>That would imply merging is totally broken.</p>
<p>When you do the merge, you need to make sure that you do merge the revision that created the file, otherwise you’ll get those warnings about no target.</p>
<p>The other thing to watch out for is if you do a merge into a working copy, then decide you’re not happy with it and revert everything, the newly added files will still be in the working copy, so if you merge again, the unversioned files will prevent the merge of new files there, so you will miss them. So running “svn status” and removing unversioned files will ensure the merge works properly.</p>
<p>The comment about adding an empty file should not be done, because then the new file has no history of where it came from. In other words, it’s not a copy, so “svn log” will not show its history. And finally, if the file were a gigabyte photo, you wouldn’t want to merge it into a new file, because then the repository would have two copies of the exact same context. Merging and copying with history saves repository storage (at least until rep-sharing is put in).</p>
]]></content>
    
    <summary type="html">
    
      记一次svn merge individual files导致后续merge遗漏更改的解决方案。
    
    </summary>
    
      <category term="SVN" scheme="https://claude-ray.github.io/categories/SVN/"/>
    
    
      <category term="SVN" scheme="https://claude-ray.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>request中文乱码问题</title>
    <link href="https://claude-ray.github.io/2018/02/26/request%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://claude-ray.github.io/2018/02/26/request中文乱码问题/</id>
    <published>2018-02-26T14:16:20.000Z</published>
    <updated>2018-10-31T14:18:40.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>可能是需要开启<code>gzip: true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;url, <span class="attr">gzip</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="buffer-decode"><a href="#buffer-decode" class="headerlink" title="buffer decode"></a>buffer decode</h3><p>可以考虑使用<code>iconv-lite</code>转换buffer。request设置<code>encoding: null</code>时，会返回buffer形式的body。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;url, <span class="attr">gzip</span>: <span class="literal">true</span>, <span class="attr">encoding</span> : <span class="literal">null</span>&#125;, (err, res, body) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> str = iconv.decode(body, <span class="string">'gb2312'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有个别网站编码不统一，时而gb2312时而utf8，这种情况需要自己判断处理。<br>可以参考<a href="https://cnodejs.org/topic/545de1e1a68535a174fe51b5" target="_blank" rel="noopener">cnode的回帖</a>——<br>先请求下来 Buffer, 也就是 request 的时候指定 encoding: null ，得到 Buffer, 用ASCII解码前一千个字符，用正则，匹配出 ; charset=(\w+)”，得到正确的 charset, 再用 iconv-lite 解码出全部的  buff。</p>
</blockquote>
<h3 id="stream-pipe"><a href="#stream-pipe" class="headerlink" title="stream pipe"></a>stream pipe</h3><p>简化一下过程，<code>iconv-lite</code>也支持pipe<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(url).pipe(iconv.decodeStream(code));</span><br></pre></td></tr></table></figure></p>
<p>Demo</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">url, code = <span class="string">'gb2312'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = <span class="string">'something.txt'</span>;</span><br><span class="line">  <span class="keyword">const</span> tempname = <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.txt`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> writeStream = fs.createWriteStream(tempname);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      request(url)</span><br><span class="line">        .pipe(iconv.decodeStream(code))</span><br><span class="line">        .pipe(writeStream)</span><br><span class="line">        .on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">          fs.renameSync(tempname, filename);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;url&#125;</span>文件下载失败,<span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Node中使用request请求得到的数据为乱码，分析可能的情况并列举解决方案。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>使用chokidar监视文件更新</title>
    <link href="https://claude-ray.github.io/2018/01/27/%E4%BD%BF%E7%94%A8chokidar%E7%9B%91%E8%A7%86%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0/"/>
    <id>https://claude-ray.github.io/2018/01/27/使用chokidar监视文件更新/</id>
    <published>2018-01-27T04:57:42.000Z</published>
    <updated>2018-10-31T14:15:18.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监视文件"><a href="#监视文件" class="headerlink" title="监视文件"></a>监视文件</h2><p>使用<code>chokidar</code>，可以监视指定路径下目录、文件的变动。由于我只关注更改，因此监视<code>change</code>事件即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chokidar = <span class="built_in">require</span>(<span class="string">'chokidar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = watchChange;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听目录或文件变动</span></span><br><span class="line"><span class="comment"> * @param &#123;string|array&#125; paths    目录或文件路径</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125;     onChange 回调函数</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise.&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchChange</span>(<span class="params">paths, onChange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`onChange (<span class="subst">$&#123;onChange&#125;</span>) is not a function`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(paths)) paths = [paths];</span><br><span class="line"></span><br><span class="line">  paths.forEach(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(path &amp;&amp; fs.existsSync(path))) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`can't find path <span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  chokidar.watch(paths)</span><br><span class="line">    <span class="comment">// .on('add', filepath =&gt; &#123;console.log('you can watch more events by chains')&#125;)</span></span><br><span class="line">    .on(<span class="string">'change'</span>, filepath =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> filename = path.basename(filepath);</span><br><span class="line">      onChange(filename);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h2><p>为了避免每次取内容都读文件，使用了<code>lodash.memoize</code>缓存读取结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getFile = _.memoize(readFile);</span><br></pre></td></tr></table></figure>
<p>要更新这部分缓存，可以使用如下方法。用大文件测试了内存占用，没有泄露产生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFile.cache.set(file, readFile(file));</span><br></pre></td></tr></table></figure>
<p>完整部分，加上了try catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchTpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    watchFiles(<span class="string">'./test'</span>, file =&gt; &#123;</span><br><span class="line">      getFile.cache.set(file, readFile(file));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watchTpl();</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于使用场景明确，代码实现较简单，没有考虑太多情况，也算不上热更新。但借这种思路，可以完成配置文件甚至功能模块的更新。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://ngtmuzi.com/Node监视文件以实现热更新/" target="_blank" rel="noopener">Node监视文件以实现热更新</a><br><a href="http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/" target="_blank" rel="noopener">Node.js Web应用代码热更新的另类思路</a></p>
]]></content>
    
    <summary type="html">
    
      为了提高文件读取效率，有时会将文件内容缓存到内存再使用。但是当文件发生更改，如何将改动更新到缓存而又不重启Node进程。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Array.map(parseInt)为什么返回了NaN</title>
    <link href="https://claude-ray.github.io/2017/12/23/Array-map-parseInt-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E4%BA%86NaN/"/>
    <id>https://claude-ray.github.io/2017/12/23/Array-map-parseInt-为什么返回了NaN/</id>
    <published>2017-12-23T11:29:48.000Z</published>
    <updated>2017-12-23T11:35:36.042Z</updated>
    
    <content type="html"><![CDATA[<p>为什么没有得到想要的<code>[1, 2, 3]</code>？先来看parseInt的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(string, radix);</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>string</code>是必传参数，要被解析的字符串，排在起始处的空格会被忽略。</li>
<li><code>radix</code>这是可选参数，但不了解的话就容易踩坑。它是一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。例如10代表十进制。此外，不指定该参数或0，均表示为以十进制。如果以<code>0x</code> 或 <code>0X</code> 开头，表示十六进制。</li>
</ul>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>parseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。</p>
<p>基数大于 10 时，用字母表中的字母来表示大于 9 的数字。例如十六进制中，使用 A 到 F。</p>
<h3 id="一些细节（keng）"><a href="#一些细节（keng）" class="headerlink" title="一些细节（keng）"></a>一些细节（keng）</h3><ol>
<li><p>一些数中可能包含e字符（例如6.022e23），使用parseInt去截取包含e字符数值部分会造成难以预料的结果。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.022e23'</span>, <span class="number">10</span>); <span class="comment">// 返回 6</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.022e2'</span>, <span class="number">10</span>);  <span class="comment">// 返回 602</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当parseInt遇到不属于radix参数所指定的基数中的字符（eg: 有人告诉你<code>0103101</code>是2进制），那么该字符（3）和其后的字符（101）都将被忽略，接着返回已经解析的整数部分（010）。parseInt 将截取整数部分，开头和结尾的空白符允许存在，会被忽略。那么NaN的出现情况就是，<code>string</code>的第一个字符（除空白）不属于radix指定进制时，因为parseInt什么都没有解析到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="string">'afdsaf'</span>); <span class="comment">// 返回123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：</p>
<ul>
<li>string 以’0x’或者’0X’开头, 则基数是16 (16进制).</li>
<li>string 以’0’开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li>
<li>string 以其它任何值开头，则基数是10 (十进制)。</li>
</ul>
</li>
<li><p>将整型数值以特定基数转换成它的字符串值可以使用 <code>intValue.toString(radix);</code></p>
</li>
</ol>
<h2 id="Array-map"><a href="#Array-map" class="headerlink" title="Array.map"></a>Array.map</h2><p>其实看完parseInt的文档就已经清晰了，再来看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">map</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>通常情况下，<code>callback</code> 只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。</p>
<ul>
<li><code>callback</code>: 生成新数组元素的函数，使用三个参数：<ul>
<li><code>currentValue</code>: 正在处理的当前元素。</li>
<li><code>index</code>: 当前元素的索引。</li>
<li><code>array</code>: map 方法被调用的数组。</li>
</ul>
</li>
<li><code>thisArg</code>: 可选，执行 callback 函数时 使用的this 值。</li>
</ul>
<blockquote>
<p>返回值是一个新数组，每个元素都是回调函数的值。</p>
</blockquote>
<h2 id="最终分析"><a href="#最终分析" class="headerlink" title="最终分析"></a>最终分析</h2><p>调用<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(console.log)</code>观察，列举出当<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>的时候发生了什么。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]);</span><br></pre></td></tr></table></figure></p>
<p>由于parseInt只接受了前两个参数，过滤掉array得到如下。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>); <span class="comment">// radix为0，按十进制输出1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>); <span class="comment">// radix为1，不满足2到36范围</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>); <span class="comment">// radix为2，将3看成二进制数，但3并不是二进制，无法转换</span></span><br></pre></td></tr></table></figure></p>
<p>再换一个数组，也可以按照此逻辑推算正确结果了。</p>
]]></content>
    
    <summary type="html">
    
      简单来说，当调用`[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)`的时候，会返回什么结果？答案是`[1, NaN, NaN]`。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="JavaScript" scheme="https://claude-ray.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>缓存不当至服务崩溃</title>
    <link href="https://claude-ray.github.io/2017/12/20/%E7%BC%93%E5%AD%98%E4%B8%8D%E5%BD%93%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%B4%A9%E6%BA%83/"/>
    <id>https://claude-ray.github.io/2017/12/20/缓存不当至服务崩溃/</id>
    <published>2017-12-20T14:45:20.000Z</published>
    <updated>2017-12-21T14:51:07.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>9月份优化的redis写缓存冲突，埋下了一个地雷。</p>
<p>回顾之前的解决方案：</p>
<p>recommend接口的返回值使用非常频繁，为了避免前端不断请求recommend接口，因此前端负责写缓存，后端负责从sql中查询数据，需要更新时再去删除此缓存。</p>
<p>这样就留下一个问题，当前端缓存过期，会迸发大量的请求到后端，当后端的sql查询速度较慢。此时前端的请求不间断，后端就堆积了大量的sql查询，影响到其他请求，甚至宕机。</p>
<p>之前没有出现问题的原因，是sql走了索引，查询速度正常。恰巧这个项目被交接之后，优化的过程中发现这条索引不合理，被删除了，但是遗漏了对recommend的修改，于是导致接口超时（查询时间大于Nginx配置的最大响应时间）。且缓存时间一周，等到它自然过期，被搞得措手不及。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>立即为recommend设置一个非空缓存，停掉前端请求</li>
<li>重启mysql</li>
<li>恢复之前的索引，保证该接口下的SQL查询处于正常水平</li>
</ol>
<blockquote>
<p>旧索引恢复之后，一些优化就失效了，mysql继续走了它自认为不错的毒瘤索引。要即刻进行后续工作。</p>
</blockquote>
<h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><ol>
<li>优化此处低效的sql(select xx where xx in xx order by，没有索引自然会崩)</li>
<li>恢复后端在该接口下写缓存的能力，使用锁（redis.setnx）或让前端走请求方式获取</li>
<li>重新删除上述索引，恢复正常优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      记录此次Bug原因和修复过程
    
    </summary>
    
      <category term="Redis" scheme="https://claude-ray.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode+evernote云笔记</title>
    <link href="https://claude-ray.github.io/2017/12/05/vscode-evernote%E4%BA%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://claude-ray.github.io/2017/12/05/vscode-evernote云笔记/</id>
    <published>2017-12-05T15:40:53.000Z</published>
    <updated>2018-10-31T14:19:08.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-Evernote"><a href="#Why-Evernote" class="headerlink" title="Why Evernote"></a>Why Evernote</h1><p>之前一直使用有道云来保存笔记，支持markdown，免费的功能满足笔记所用，界面也还算可以。缺点是有广告，还经历了几次服务崩溃和笔记丢失，虽然联系客服又找回来了，但终究是越用越不爽。</p>
<p>支持markdown的云笔记非常多，可以凭喜好选择。但要说云笔记软件哪款做的最好，我更倾心于evernote。</p>
<p>evernote作为知识收藏库非常便捷，然而只有markdown才能支撑我将它作为笔记端使用。之前不使用它的唯一原因就是不支持markdown的预览，但想让它存储markdown的方法却非常多。</p>
<h1 id="云编辑"><a href="#云编辑" class="headerlink" title="云编辑"></a>云编辑</h1><p>开源的markdown云笔记：</p>
<ul>
<li>Leanote 看到知乎的吐槽，伪开源，自建服务器会很坑</li>
<li><a href="https://stackedit.io/" target="_blank" rel="noopener">Stack Edit</a>，对中文支持不太友好，可同步到Google Drive，Dropbox和github。</li>
</ul>
<p>如果不介意笔记安全，可以购买以下这类第三方服务</p>
<ul>
<li><code>马克飞象</code> 试用后认为很赞，但是一人维护也难免出现一些bug</li>
<li><code>小书匠</code> 免费不开源，界面不喜欢</li>
<li><code>有道云笔记</code> 免费够用</li>
<li><code>为知笔记</code> 要付费使用</li>
<li><code>作业部落Cmd</code></li>
<li>…</li>
</ul>
<p>有兴趣可以自己比较优劣，只能说试用过后，上面都不是我想要的，不过多赘述。</p>
<h1 id="本地编辑"><a href="#本地编辑" class="headerlink" title="本地编辑"></a>本地编辑</h1><p>文档断电丢失的担忧是过去式了，本地编辑方便使用熟悉的快捷键和指法，可以提高编辑效率。</p>
<p>如果你接受在本地编辑，或者在离线环境下写东西，联网之后再保存笔记到云端，那么就来尝试这种方法吧。</p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>所见即所得。</p>
<p>把编辑和预览结果放在了一个文本框中，对于习惯裸写markdown的无所谓，但的确是一种不错的风格。</p>
<p>绑定网盘之后可以将md文件同步到网盘上，仍然和我理想中的云笔记有差距。对我个人来说，云笔记更重要的功能是阅读而不是编辑，方便随时查阅。</p>
<h2 id="Evermonkey"><a href="#Evermonkey" class="headerlink" title="Evermonkey"></a>Evermonkey</h2><p>如果你使用sublime，应该知道有一款<code>sublime-evernote</code>插件可以使本地的markdown同步到evernote笔记中。而我更常用vscode，对markdown原生的支持就不错。vscode的一款开源插件<code>evermonkey</code>，也实现了同样的功能。</p>
<h3 id="缺憾"><a href="#缺憾" class="headerlink" title="缺憾"></a>缺憾</h3><ol>
<li>不支持双向编辑，markdown的终稿放在博客，或者打包成附件加到该笔记中更合适。</li>
<li><code>[TOC]</code>的bug？目录树可以生成，但是在印象笔记中点击链接无法跳转到正确位置。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>ever new</code> 新建笔记</li>
<li><code>ever publish</code> 发布笔记</li>
<li><code>ever recent</code> 打开最近编辑的笔记</li>
<li><code>ever open</code> 可按照目录树逐级打开</li>
<li><code>ever search</code> 使用evernote的搜索接口</li>
<li><code>ever attach</code> 添加附件</li>
<li><code>ever resources</code> 查看现在添加了哪些附件</li>
<li><code>ever unattach</code> 删除附件</li>
</ul>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>不幸的是，evernote禁止了<code>developer tokens</code>的申请，已经拥有tokens的用户将不受影响。</p>
<p>但这并不代表新用户无法使用tokens了，你可以写下申请原因，以向evernote提交<code>tickets</code>的形式来申请tokens。按照官网的说法可能要一周才回复，实际上不到半天我就收到了客服的批准答复。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>不建议在工具“选择”上浪费太多时间，愿意折腾就都玩一遍，不想折腾就认清自己的需求，选择一款方便转移文档（跑路）的即可。新的工具层出不穷，时下更成熟的那款终会浮现出现。</p>
<p>工具不能提升技术，但是可以提高效率。信仰加成~</p>
]]></content>
    
    <summary type="html">
    
      个人笔记这种重要东西，放在墙内是不放心的，由于内容基础又杂乱，不能像博客一样托管到github或gitbook，适合单独找一个地方存放。由于习惯使用Markdown记录笔记，主要为了查阅方便，我上个月瞄向了不支持Markdown格式的Evernote，借插件实现Markdown笔记存储。
    
    </summary>
    
      <category term="随笔" scheme="https://claude-ray.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>lodash3升级4踩坑</title>
    <link href="https://claude-ray.github.io/2017/10/05/lodash-3-to-4/"/>
    <id>https://claude-ray.github.io/2017/10/05/lodash-3-to-4/</id>
    <published>2017-10-05T01:15:09.000Z</published>
    <updated>2018-12-11T16:05:56.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lodash版本问题"><a href="#lodash版本问题" class="headerlink" title="lodash版本问题"></a>lodash版本问题</h2><p>近期更新了lodash包，<code>3.x</code> 到最新的 <code>4.17.x</code>，然后就发现系统拿不到数据了。</p>
<p>最终定位到 <code>lodash.merge</code> 方法。</p>
<p>lodash.merge有一个常用的特性，即._merge(source, […abc])，merge会自动过滤到后面参数中undefined的属性。然而，<code>4.17.x</code> 的 lodash 不再支持。这个是根据论坛其他人的评论和官方的history.md发现的，然而一年过去了，lodash的官方文档却没有更新这一点……</p>
<p>如果仍想用到过滤 <code>undefined</code> 的特性，就需要使用 <code>_.omitBy(myObj, _.isNil)</code> 或者 <code>_.pickBy(myObj)</code> 包装或替换原使用 <code>_.merge(myObj, [...source])</code> 的地方。</p>
<h2 id="npm安装失败"><a href="#npm安装失败" class="headerlink" title="npm安装失败"></a>npm安装失败</h2><p>升级lodash的过程中，在某个服务器失败了，报错内容为：</p>
<blockquote>
<p>nnpm ERR! path /var/xxx/node_modules/fs-extra_back/node_modules/graceful-fs/node_modules/natives npm ERR! code ENOENT npm ERR! errno -2 npm ERR! syscall access npm ERR! enoent ENOENT: no such file or directory, access ‘/var/xxx/node_modules/fs-extra_back/node_modules/graceful-fs/node_modules/natives’ npm ERR! enoent This is related to npm not being able to find a file. npm ERR! enoent npm ERR! A complete log of this run can be found in: npm ERR! /root/.npm/_logs/2017-09-29T07_39_30_928Z-debug.log</p>
</blockquote>
<p>google了一下 <code>ENOENT</code> 相关错误，提取众人反映问题的共同点就是，npm5。在npm4甚至3的环境下是没有这种情况的，服务器也是近期升级了npm版本。<br>不过比起npm降级，采取了更简便的方法，将access ‘/xxx’的npm包删除就好啦~</p>
]]></content>
    
    <summary type="html">
    
      记录lodash升级过程中不兼容的点，以及偶遇的npm包安装异常。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Lodash" scheme="https://claude-ray.github.io/tags/Lodash/"/>
    
      <category term="npm" scheme="https://claude-ray.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Node获取GBK编码“字符串”</title>
    <link href="https://claude-ray.github.io/2017/10/05/node-gbk-hex/"/>
    <id>https://claude-ray.github.io/2017/10/05/node-gbk-hex/</id>
    <published>2017-10-05T00:50:46.000Z</published>
    <updated>2018-12-11T16:03:10.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UTF8-to-GBK-Hex-String"><a href="#UTF8-to-GBK-Hex-String" class="headerlink" title="UTF8 to GBK Hex String"></a>UTF8 to GBK Hex String</h1><h2 id="iconv-lite"><a href="#iconv-lite" class="headerlink" title="iconv-lite"></a>iconv-lite</h2><p>通常都会使用 <code>iconv-lite</code> 这个包实现Node的编码转换，但是这个包是基于 <code>Buffer</code> 的，如果传递给其他语言的系统，需要先转换为 <code>String</code> 字符串。</p>
<p>在网上查阅了相关资料，并没有给出很好的解答。一些比较老的回答都在说，Node中无法把Buffer转换成gbk字符串。</p>
<p>俗话说有问题找师兄，果然，咨询同组师兄后得到了期望的结果。转换过程很巧妙，在此分享出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toGBKString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iconv.encode(str, <span class="string">'gbk'</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span><span class="subst">$&#123;cur.toString(<span class="number">16</span>)&#125;</span>`</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是不加百分号的，如果需要可以在模板字符串中自行加上。</p>
<h2 id="2018-04-18更"><a href="#2018-04-18更" class="headerlink" title="2018-04-18更"></a>2018-04-18更</h2><p>由于<code>Buffer</code>本身支持hex的转换</p>
<blockquote>
<p>Buffer instances are commonly used to represent sequences of encoded characters such as UTF-8, UCS2, Base64, or even Hex-encoded data. It is possible to convert back and forth between Buffer instances and ordinary JavaScript strings by using an explicit character encoding.</p>
</blockquote>
<blockquote>
<p>‘hex’ - Encode each byte as two hexadecimal characters.</p>
</blockquote>
<p>因此<code>reduce</code>可以继续简化为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv.encode(str, <span class="string">'gbk'</span>).toString(<span class="string">'hex'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      首先，Node内部是无法直接获取GBK编码“字符串”的，只不过使用到GBK的场景均有相应的应对方法。最初学习时，陷入了接口返回值必须是“字符串”的误区，然而想把GBK编码从Buffer强转为GBK中文String类型是做不到的。本篇借助了hex码，达成了字符串形式传输GBK数据的需要，用以发送给其他语言编写的系统。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="String" scheme="https://claude-ray.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Express源码分析</title>
    <link href="https://claude-ray.github.io/2017/07/24/Express%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://claude-ray.github.io/2017/07/24/Express源码分析/</id>
    <published>2017-07-24T14:54:05.000Z</published>
    <updated>2018-10-31T14:17:09.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express源码分析"><a href="#Express源码分析" class="headerlink" title="Express源码分析"></a>Express源码分析</h1><h2 id="项目整体结构"><a href="#项目整体结构" class="headerlink" title="项目整体结构"></a>项目整体结构</h2><p>相较于 <code>4.15.2</code> ， <code>4.15.3</code> 又一次移除了所有内部<code>node_modules</code>，目录结构恢复整洁。</p>
<blockquote>
<p><code>4.15.2</code> 中的内置的 <code>node_modules</code> 是 <code>debug</code>。</p>
</blockquote>
<h2 id="Express-内部文件"><a href="#Express-内部文件" class="headerlink" title="Express 内部文件"></a>Express 内部文件</h2><h3 id="1-程序入口-index-js"><a href="#1-程序入口-index-js" class="headerlink" title="1 程序入口 index.js"></a>1 程序入口 <code>index.js</code></h3><p>只是一个简单的入口，导出了<code>lib/express</code>。</p>
<h3 id="2-应用创建-express-js"><a href="#2-应用创建-express-js" class="headerlink" title="2 应用创建 express.js"></a>2 应用创建 <code>express.js</code></h3><ol>
<li><p>从入口程序进入这里，第一句就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = module.exports = createApplication;</span><br></pre></td></tr></table></figure>
<p>对这个写法进行总结：</p>
<ul>
<li>API文档中有详细解释， <code>exports</code> 就是一个shortcut。所有供外部调用的方法或变量均需挂载在exports变量上，<br>当需要将一个文件当做一个类导出时，就需要通过 <code>module.exports</code> 而不是 <code>exports</code>。</li>
<li>进一步讲讲， <code>exports</code> 是 <code>module.exports</code> 的引用，他们的初值都是空对象 <code>{}</code>。<br>require加载模块时使用的是 <code>module.exports</code> 而不是 <code>exports</code>。<br>搞不清楚关系的一直使用<code>module.exports</code>也没问题。</li>
<li>module.exports 指向新的对象时，exports 断开了与 module.exports 的引用。<br>而API上的说法不然， <code>When the module.exports property is being completely replaced by a new object, it is common to also reassign exports</code> 。<br>起初我从直观上理解，认为两者说辞是相反的，且经过验证，exports 确实会断开引用。因此是对API说明的理解有偏差。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面写法等价于</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.exports 指向新的对象时，exports 断开了与 module.exports 的引用</span></span><br><span class="line"><span class="built_in">module</span>.exports = createApplication;</span><br><span class="line"><span class="comment">// 若还想使用exports添加属性，让 exports 重新指向 module.exports 即可</span></span><br><span class="line">exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>express.js</code> 返回一个 app 作为 <code>createApplication</code> 的回调函数每个http请求都可以触发执行 <code>app.handle</code> 来执行中间件。<br><code>app.handle</code> 调用了router组件的 <code>handle(req, res, out)</code> 函数链式执行中间件。<br>通过 <a href="#merge-descriptors"><code>merge-descriptors</code></a> 中间件将 <code>application</code> 和 <code>events.EventEmitter</code> 合并(类似于继承)到 app 中。<br>而 <code>app.request</code> 和 <code>app.response</code> 通过 <code>Object.create</code> 方式继承request和response得到。完成以上操作后，调用 <code>application.init()</code> 进行初始化。</p>
</li>
<li>通过 <code>exports</code> 暴露出 express 内主要的构造器、原型。</li>
<li>末尾处遍历的数组内是已经移除的 <code>Express 3.x</code> 内置模块，当使用者不知情而直接使用时，提醒他们需要额外安装，提供了更友好的报错信息。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">'json'</span>,</span><br><span class="line">  <span class="string">'urlencoded'</span>,</span><br><span class="line">  <span class="string">'bodyParser'</span>,</span><br><span class="line">  <span class="string">'compress'</span>,</span><br><span class="line">  <span class="string">'cookieSession'</span>,</span><br><span class="line">  <span class="string">'session'</span>,</span><br><span class="line">  <span class="string">'logger'</span>,</span><br><span class="line">  <span class="string">'cookieParser'</span>,</span><br><span class="line">  <span class="string">'favicon'</span>,</span><br><span class="line">  <span class="string">'responseTime'</span>,</span><br><span class="line">  <span class="string">'errorHandler'</span>,</span><br><span class="line">  <span class="string">'timeout'</span>,</span><br><span class="line">  <span class="string">'methodOverride'</span>,</span><br><span class="line">  <span class="string">'vhost'</span>,</span><br><span class="line">  <span class="string">'csrf'</span>,</span><br><span class="line">  <span class="string">'directory'</span>,</span><br><span class="line">  <span class="string">'limit'</span>,</span><br><span class="line">  <span class="string">'multipart'</span>,</span><br><span class="line">  <span class="string">'staticCache'</span>,</span><br><span class="line">].forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(exports, name, &#123;</span><br><span class="line">    get         : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Most middleware (like '</span> + name + <span class="string">') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-应用-application-js"><a href="#3-应用-application-js" class="headerlink" title="3 应用 application.js"></a>3 应用 <code>application.js</code></h3><h4 id="初始化-app-defaultConfiguration"><a href="#初始化-app-defaultConfiguration" class="headerlink" title="初始化 app.defaultConfiguration"></a>初始化 <code>app.defaultConfiguration</code></h4><ol>
<li><p>虽然在 <code>createApplication</code> 中调用的是app.init()，但查看 <code>application.js</code> 的init就会发现，init只是在初始化应用之前为一些属性赋了空值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - setup default configuration</span></span><br><span class="line"><span class="comment"> *   - setup default middleware</span></span><br><span class="line"><span class="comment"> *   - setup route reflection methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.engines = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.settings = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 调用真正的初始化方法</span></span><br><span class="line">  <span class="keyword">this</span>.defaultConfiguration();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultConfiguration解析。</p>
<blockquote>
<p>在这里单步执行，可以直观查看所有默认默认信息。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize application configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.defaultConfiguration = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化app的默认配置</span></span><br><span class="line">  <span class="keyword">let</span> env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default settings</span></span><br><span class="line">  <span class="keyword">this</span>.enable(<span class="string">'x-powered-by'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'etag'</span>, <span class="string">'weak'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'env'</span>, env);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'query parser'</span>, <span class="string">'extended'</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'subdomain offset'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'trust proxy'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.settings, trustProxyDefaultSymbol, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value       : <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">'booting in %s mode'</span>, env);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听 mount 事件：当向express添加中间件时就会触发</span></span><br><span class="line">  <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onmount</span>(<span class="params">parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// inherit trust proxy</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.settings[trustProxyDefaultSymbol] === <span class="literal">true</span></span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> parent.settings[<span class="string">'trust proxy fn'</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.settings[<span class="string">'trust proxy'</span>];</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.settings[<span class="string">'trust proxy fn'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inherit protos</span></span><br><span class="line">    <span class="comment">// 将每个中间件的request, response, engine, settings对象的__proto__形成原型链</span></span><br><span class="line">    <span class="comment">// 最顶层的request, response对象是Node原生的request和response对象，在createApplication中定义</span></span><br><span class="line">    <span class="comment">// 源码是: setPrototypeOf(this.request, parent.request); ...</span></span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="keyword">this</span>.request.__proto__ = parent.request.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.response.__proto__ = parent.response.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.engine.__proto__ = parent.engine.__proto__;</span><br><span class="line">    <span class="keyword">this</span>.settings.__proto__ = parent.settings.__proto__;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup locals</span></span><br><span class="line">  <span class="keyword">this</span>.locals = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// top-most app is mounted at /</span></span><br><span class="line">  <span class="keyword">this</span>.mountpath = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default locals</span></span><br><span class="line">  <span class="keyword">this</span>.locals.settings = <span class="keyword">this</span>.settings;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//default configuration</span></span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'view'</span>, View);</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'views'</span>, resolve(<span class="string">'views'</span>));</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'jsonp callback name'</span>, <span class="string">'callback'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.enable(<span class="string">'view cache'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'router'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'\'app.router\' is deprecated!\nPlease update your app.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="添加中间件-app-use"><a href="#添加中间件-app-use" class="headerlink" title="添加中间件 app.use"></a>添加中间件 <code>app.use</code></h4><h4 id="渲染视图-app-render"><a href="#渲染视图-app-render" class="headerlink" title="渲染视图 app.render"></a>渲染视图 <code>app.render</code></h4><h3 id="请求扩展-request-js"><a href="#请求扩展-request-js" class="headerlink" title="请求扩展 request.js"></a>请求扩展 <code>request.js</code></h3><h3 id="响应扩展-response-js"><a href="#响应扩展-response-js" class="headerlink" title="响应扩展 response.js"></a>响应扩展 <code>response.js</code></h3><h2 id="关联的其他模块"><a href="#关联的其他模块" class="headerlink" title="关联的其他模块"></a>关联的其他模块</h2><h3 id="merge-descriptors"><a href="#merge-descriptors" class="headerlink" title="merge-descriptors"></a>merge-descriptors</h3><ul>
<li>源码很简单，通过foreach循环，依次将源对象的元素合并给目标对象。没有用到<code>Object.defineProperties</code> ，而是对每个操作符进行判断。<br>如果 <code>redefine</code> (undefined则赋值为true)设置为false并且某一属性目标对象已经包含，则不再进行处理。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge-descriptors 的简化实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">dest, src, redefine</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// check</span></span><br><span class="line">  <span class="keyword">if</span> (!dest || !src) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'dest or src is required'</span>);</span><br><span class="line">  <span class="keyword">if</span> (redefine === <span class="literal">undefined</span>) redefine = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(src).forEach(<span class="function"><span class="keyword">function</span> <span class="title">forEachOwnPropertyName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// skip</span></span><br><span class="line">    <span class="keyword">if</span> (!redefine &amp;&amp; hasOwnProperty.call(dest, name)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(src, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(dest, name, descriptor);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      新坑，基于 Express@4.15.3 的源码分析，慢慢填
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://claude-ray.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建过程</title>
    <link href="https://claude-ray.github.io/2017/06/18/Hexo%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>https://claude-ray.github.io/2017/06/18/Hexo搭建过程/</id>
    <published>2017-06-18T14:09:28.000Z</published>
    <updated>2017-12-19T14:46:51.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里只列出 hexo 的简明搭建方法，不讲“是什么”和“为什么”，关于 hexo 的更多配置和用法请前往 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Docs</a>  了解。</p>
<h4 id="Node-js-环境"><a href="#Node-js-环境" class="headerlink" title="Node.js 环境"></a>Node.js 环境</h4><p>必须安装Node，方式任选，不多说</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>通过 Node 的 npm 安装 Hexo，命令行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm i -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h4 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt; <span class="comment"># 初始化项目名称 </span></span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt; </span><br><span class="line">$ npm install <span class="comment"># 安装模块</span></span><br></pre></td></tr></table></figure>
<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 必要时，清除上次生成页面时造成的缓存 </span></span><br><span class="line">$ hexo g  <span class="comment"># 生成静态页面 </span></span><br><span class="line">$ hexo s  <span class="comment"># 在本地启动Hexo，可以在浏览器访问 localhost:4000 来预览</span></span><br></pre></td></tr></table></figure>
<h4 id="GitHub-支持"><a href="#GitHub-支持" class="headerlink" title="GitHub 支持"></a>GitHub 支持</h4><p>首先在 GitHub 按照 <code>username.github.io</code> 的格式新建仓库，之后在项目根目录下执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>打开 <code>_config.yml</code> ，编辑 <code>deploy</code>字段，注意替换用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourusername/yourusername.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>配置完成后，只需执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<p>即可将本地内容部署在 GitHub 中，输入域名 <code>username.github.io</code> 进行访问</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><blockquote>
<p>如果不喜欢默认主题，可以参考如下方式更改。</p>
</blockquote>
<p>要把主题更换为Next，先定位到Hexo站点目录进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>之后打开站点配置文件 <code>_config.yml</code>，修改 <code>theme</code> 字段值为 <code>next</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<h4 id="修改Scheme"><a href="#修改Scheme" class="headerlink" title="修改Scheme"></a>修改Scheme</h4><p>Next主题提供了3种Scheme，也决定了外观细节，需要在主题配置文件 <code>themes/next/_config.yml</code> 中进行修改，通过注释和反注释三选一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br></pre></td></tr></table></figure></p>
<h4 id="修改菜单"><a href="#修改菜单" class="headerlink" title="修改菜单"></a>修改菜单</h4><p>在主题配置文件中，找到 <code>menu</code> 字段并进行适当修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  about: /about</span><br><span class="line">  #categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure></p>
<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>同样在主题配置文件中修改 <code>avatar</code> 字段，可以参照注释把avatar图片存在 <code>next/source/images</code> 目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure></p>
<h4 id="阅读统计"><a href="#阅读统计" class="headerlink" title="阅读统计"></a>阅读统计</h4><p>为文章增加字数统计和阅读时长字段，需要安装wordcount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount --save</span><br></pre></td></tr></table></figure></p>
<p>最新的2017 next主题已经内置了<code>hexo-wordcount</code>，接下来就可以在主题配置文件<code>_config.yml</code>中，修改如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></p>
<p>关于单篇博客阅读人数的统计，我使用了<code>LeanCloud</code>，而非<code>不蒜子</code>，同样都在next主题中内置。主要原因是<code>不蒜子</code>不能在首页显示阅读统计，此外<code>LeanCloud</code>还提供了一定的管理功能。需要在主题配置文件中修改如下字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: </span><br><span class="line">  app_key:</span><br></pre></td></tr></table></figure>
<h4 id="进阶设定"><a href="#进阶设定" class="headerlink" title="进阶设定"></a>进阶设定</h4><p>官方文档介绍的很详细，请首先查阅<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next使用文档</a></p>
<h3 id="遇到的坑和问题汇总"><a href="#遇到的坑和问题汇总" class="headerlink" title="遇到的坑和问题汇总"></a>遇到的坑和问题汇总</h3><h4 id="404页面配置"><a href="#404页面配置" class="headerlink" title="404页面配置"></a>404页面配置</h4><p>常规的方法是在主题目录即 <code>theme/next/source</code> 下新建 <code>404.html</code> 文件，修改主题配置文件中的<code>commonweal</code>字段，在本地预览404就能看到对应界面。但是，这么配置到GitHub pages就访问不到404页面了。</p>
<blockquote>
<p>网上给出原因是404页面只能绑定顶级域名，如果只用github.io，404页面就失去效果。</p>
</blockquote>
<p>其实，主要原因是Github Pages强制使用https，所以文档内对js和css的请求也都需要经过https才能传输，而腾讯公益404页面默认使用http。<br>所以，只要把出问题的js文件拿到本地进行修改就好了~</p>
<ul>
<li>原本的search_children.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _base = <span class="string">'http://qzone.qq.com/gy/404/'</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="'</span> + _base + <span class="string">'data.js" charset="utf-8"&gt;&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="'</span> + _base + <span class="string">'page.js" charset="utf-8"&gt;&lt;/script&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>初次修改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _base = <span class="string">'https://qzone.qq.com/gy/404/'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制台发现仍然有js文件没有加载进来，阅读 <code>page.js</code> 的代码后明白了，于是 <code>page.js</code> 也拿到本地，修改必要的url为https，终于显示正常了<br>但是有一行貌似没什么用的代码，注释掉了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getData("http://boss.qzone.qq.com/fcg-bin/fcg_zone_info");</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了增强可读性，移除上述js文件，代码直接写入HTML。但出现新问题，返回链接变成默认的腾讯主页了。<br>解决办法是修改 <code>page.js</code> 中如下判断语句条件， <code>search_children.js</code> 改为 <code>data.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (scs[i].src.indexOf(<span class="string">"/404/search_children.js"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageUrl"</span>)) &#123;</span><br><span class="line">    homePageUrl = scs[i].getAttribute(<span class="string">"homePageUrl"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageName"</span>)) &#123;</span><br><span class="line">    homePageName = scs[i].getAttribute(<span class="string">"homePageName"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然页面能正常显示了，但控制台提示提取到的儿童图片url仍然是http，解决这个问题需要在 <code>page.js</code> 中的 <code>resolveData(d)</code> 函数中对数据格式化。<br>在其中的for循环添加一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.data[i].child_pic = d.data[i].child_pic.replace(/^http/, &quot;https&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Finally! 发现了新版的 <code>http://www.qq.com/404/</code> ，logo也更美观了，果断修改。代码再次整洁了，完整如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Claude&apos;s Home - 404&lt;/title&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">        src=&quot;https://qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span><br><span class="line">        charset=&quot;utf-8&quot;</span><br><span class="line">        homePageUrl=&quot;https://claude-ray.github.io/&quot;</span><br><span class="line">        homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>感觉瞎折腾了 XD ！</p>
<h4 id="About页面"><a href="#About页面" class="headerlink" title="About页面"></a>About页面</h4><p>相同主题下，查看他人的 <code>about</code> 页面时，侧栏 <code>sidebar</code> 不会自动弹出，而我的居然会弹出……<br>难道因为 <code>#</code> 标题被当做post了？强迫症下查阅了很多相关文章，还没有发现官方的解决方案，看他们博客的意思是搭建的过程中也仅用了<code>hexo new page about</code>。<br>但回头一想，反正也不难看，就舒舒服服地按 <code>Markdown</code> 的习惯写着吧。</p>
<p>临时解决方案：<br>可以通过在 Markdown 中插入 HTML 标签的方法，移除Markdown的标题判定。</p>
]]></content>
    
    <summary type="html">
    
      使用Hexo打造个人GitHub Pages的简要过程
    
    </summary>
    
      <category term="Hexo" scheme="https://claude-ray.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://claude-ray.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://claude-ray.github.io/2017/06/14/hello-world/"/>
    <id>https://claude-ray.github.io/2017/06/14/hello-world/</id>
    <published>2017-06-13T16:29:04.000Z</published>
    <updated>2017-06-13T16:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
