<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claude&#39;s Blog</title>
  
  <subtitle>Searching</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://claude-ray.github.io/"/>
  <updated>2019-08-14T14:40:46.918Z</updated>
  <id>https://claude-ray.github.io/</id>
  
  <author>
    <name>Claude Ray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx SWRR 算法解读</title>
    <link href="https://claude-ray.github.io/2019/08/10/nginx-swrr/"/>
    <id>https://claude-ray.github.io/2019/08/10/nginx-swrr/</id>
    <published>2019-08-10T05:13:49.000Z</published>
    <updated>2019-08-14T14:40:46.918Z</updated>
    
    <content type="html"><![CDATA[<p>Smooth Weighted Round-Robin (SWRR) 是 nginx 默认的加权负载均衡算法，它的重要特点是平滑，避免低权重的节点长时间处于空闲状态，因此被称为平滑加权轮询。</p><blockquote><p>该算法来自 nginx 的一次 commit：<a href="https://github.com/phusion/nginx/commit/27e94984486058d73157038f7950a0a36ecc6e35" target="_blank" rel="noopener">Upstream: smooth weighted round-robin balancing</a></p></blockquote><p>在阅读之前，你应该已经了解过 nginx 的几种负载均衡算法，并阅读了 SWRR 的实现。</p><p>介绍此算法的文章有很多，但还没发现哪里用数学角度给出证明过程的，虽然并不复杂，这里把自己粗劣的思路分享一下。为了便于理解，只考虑算法核心的 current_weight，忽略受异常波动影响的 effective_weight。</p><a id="more"></a><hr><p>假设有三个服务器节点 A B C，它们的权重分别为 Wa、Wb、Wc 并保持不变。根据 SWRR 算法，用 CWa CWb CWc 分别表示每台服务器的当前权重，初始值均为 0。Wn 表示所有服务器节点权重的总和，即 Wn = Wa + Wb + Wc。</p><p>每次开始选择，各节点的 CW 会增加对应 W 值的大小。从中选择 CW 最大的节点，并将其值减去 Wn。</p><p>不妨设 A 为权重最大的节点，首次开始选择时，当前权重均为 0</p><table><thead><tr><th>CWa</th><th>CWb</th><th>CWc</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>经过加权</p><table><thead><tr><th>CWa</th><th>CWb</th><th>CWc</th></tr></thead><tbody><tr><td>Wa</td><td>Wb</td><td>Wc</td></tr></tbody></table><p>W 中最大值为 Wa，减去 Wn，可以表示为 CWa = Wa - Wn = 0 - (Wb + Wc)</p><table><thead><tr><th>CWa</th><th>CWb</th><th>CWc</th></tr></thead><tbody><tr><td>1 * Wa - Wn * 1</td><td>Wb</td><td>Wc</td></tr><tr><td>-(Wb+Wc)</td><td>Wb</td><td>Wc</td></tr></tbody></table><p>依此类推，第二次选择之后，CW 变为</p><table><thead><tr><th>CWa</th><th>CWb</th><th>CWc</th></tr></thead><tbody><tr><td>2 * Wa - Wn * 2</td><td>2 * Wb</td><td>2 * Wc</td></tr></tbody></table><p>根据算法，无论选择哪个节点，每次轮询的操作等于降低最大的权重，逐步提高最小值的权重，但 CW 的总和始终为 0。</p><p>不妨设 n = n1 + n2 + n3，每次选择的结果都可以表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 = n * Wa + n * Wb + n * Wc - n * Wn</span><br><span class="line">  = (n * Wa - n1 * Wn) + (n * Wb - n2 * Wn) + (n * Wc - n3 * Wn)</span><br><span class="line">  = (n ＊ Wa - n * Wn) + Wb + n * Wc</span><br></pre></td></tr></table></figure><p>第 n 次选择之后，CW 等同于</p><table><thead><tr><th>CWa</th><th>CWb</th><th>CWc</th></tr></thead><tbody><tr><td>n * Wa - Wn * n</td><td>n * Wb</td><td>n * Wc</td></tr></tbody></table><p>因此当选择次数达到 Wn 时，平衡关系为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wn * 0 = Wn * (Wa + Wb + Wc - Wn)</span><br><span class="line">       = (Wn * Wa - Wa * Wn) + (Wn * Wb - Wb * Wn) + (Wn * Wc - Wc * Wn)</span><br></pre></td></tr></table></figure><p>此时 CW 又重新回到 0 的起点，证得此轮询是一个周期，且周期长度等于权重之和，每个节点分别被选中了等于各自权重值的次数。</p><p>更多节点的证明同上。</p><hr><p>相比普通的轮询选择，高权重的节点在此过程中不断让权给低权节点，实现平滑轮询。</p><p>至于增加了的 effective_weight 概念，变数在于每次选中后 CW 减去的 Wn 总权重变为总当前权重。随着代码阅读很容易理解，就不单独证明了。</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>碰巧读到了这篇 <a href="https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/" target="_blank" rel="noopener">nginx平滑的基于权重轮询算法分析</a>，里面证明严谨多了，XD，是我之前想看的数学推理，在此推荐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Smooth Weighted Round-Robin (SWRR) 是 nginx 默认的加权负载均衡算法，它的重要特点是平滑，避免低权重的节点长时间处于空闲状态，因此被称为平滑加权轮询。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该算法来自 nginx 的一次 commit：&lt;a href=&quot;https://github.com/phusion/nginx/commit/27e94984486058d73157038f7950a0a36ecc6e35&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Upstream: smooth weighted round-robin balancing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在阅读之前，你应该已经了解过 nginx 的几种负载均衡算法，并阅读了 SWRR 的实现。&lt;/p&gt;
&lt;p&gt;介绍此算法的文章有很多，但还没发现哪里用数学角度给出证明过程的，虽然并不复杂，这里把自己粗劣的思路分享一下。为了便于理解，只考虑算法核心的 current_weight，忽略受异常波动影响的 effective_weight。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://claude-ray.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://claude-ray.github.io/tags/Nginx/"/>
    
      <category term="load balance" scheme="https://claude-ray.github.io/tags/load-balance/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Node.js 进程挂起的 BUG 追踪</title>
    <link href="https://claude-ray.github.io/2019/08/08/node-hang-up/"/>
    <id>https://claude-ray.github.io/2019/08/08/node-hang-up/</id>
    <published>2019-08-08T13:31:02.000Z</published>
    <updated>2019-08-08T15:58:32.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先把干货放前面，辅助排查的 npm 模块有：<a href="https://github.com/myndzi/wtfnode" target="_blank" rel="noopener">wtfnode</a>，why-is-node-running，active-handles 等，使用方法差不多如下，可以查看各自的文档。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wtf = <span class="built_in">require</span>(<span class="string">'wtfnode'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// your codes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// track down</span></span><br><span class="line">wtf.dump();</span><br></pre></td></tr></table></figure><p>也可以更深入地排查，因为上述模块的核心都是 Node.js 文档未标注的两个接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process._getActiveHandles();</span><br><span class="line">process._getActiveRequests();</span><br></pre></td></tr></table></figure><p>好了，本篇到这里结束了，剩下的内容，劝你还是跳过吧：流水帐警告⚠️️ 翻车警告⚠️️</p><a id="more"></a><h1 id="问题经过"><a href="#问题经过" class="headerlink" title="问题经过"></a>问题经过</h1><p>背景是为 ts + egg 项目引入 apm 探针，由于 apm 必须在“启动文件”的第一行完成加载，即整个 egg 的生命周期开始之前，因此需要使用独立的脚本或指令进行启动。具体如何处理可以参考这篇<a href="https://claude-ray.github.io/2019/07/12/elastic-apm-node-egg">博客</a>。</p><p>问题就出在脱离了 egg 的声明周期，得额外管理不同运行环境下 apm-server（APM 数据采集服务器）的地址配置。可能第一时间就能想到 Node.js 的环境变量，思路没错，毕竟程序和 egg-bin 绑定，NODE_ENV 环境变量的命名符合规范，主要为 development、test、production。特定环境读取特定的即可。</p><p>但调试过程中，写错了 apm-server 路径，遇到了进程启动过程中卡住的现象。解决起来很容易，但好奇是什么原因造成的，因为正常引入 elastic-apm-node 并填写一个错误的 url 并不妨碍主流程的运行。</p><h1 id="战前准备"><a href="#战前准备" class="headerlink" title="战前准备"></a>战前准备</h1><p>省略翻代码的过程，简单的结论就是：进程卡死的问题由 egg-bin 内置的 ets（egg-ts-helper）指令诱发，其使用 <code>child_process.execSync</code> 方法启动子进程来预加载一部分代码用作检查，而子进程卡住不退出，才导致父进程无法继续向下执行。</p><blockquote><p>ets 执行 execSync 的位置：<a href="https://github.com/whxaxes/egg-ts-helper/blob/master/src/utils.ts#L107" target="_blank" rel="noopener">https://github.com/whxaxes/egg-ts-helper/blob/master/src/utils.ts#L107</a> 其中 cmd 的内容是执行 <code>./scripts/eggInfo</code> 文件。eggInfo 指令了 egg 的 loader 来获取插件信息，因此 apm 作为生命周期之前的模块被顺便加载了。</p></blockquote><p>经过检查和断点调试，已经找出进程无法正常退出的根源在 <code>elasitc-apm-http-client</code> 模块和 <code>apm-server</code> 的通讯之间。并且如果把 apm-server 的目标地址改成本机未使用的端口，如 <code>http://localhost:8201</code>，进程可迅速地正常退出。但如果填写一个错误地或不存在的地址，例如 <code>http://10.10.10.10:8200</code> ，以致访问超时，进程就会挂起。</p><h1 id="开始狩猎"><a href="#开始狩猎" class="headerlink" title="开始狩猎"></a>开始狩猎</h1><p>我们已经缩小了问题重现的范围，就可以仔细阅读代码了。</p><p>首先看向 http client 创建的步骤，唯一值得注意的点是一个轮询操作。apm 创建时默认开启了 elastic-apm-http-client 的 <code>centralConfig</code> 选项，此功能是允许在 Kibana 看板上直接修改 apm agent 的配置而无须重启 Node.js 进程，实现原理便是轮询 apm-server 以查询最新的配置信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Client.prototype._pollConfig = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> req = <span class="keyword">this</span>._transport.get(opts, res =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._scheduleNextConfigPoll()</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'request-error'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Client.prototype._scheduleNextConfigPoll = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._configTimer !== <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  seconds = seconds || <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._configTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._configTimer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>._pollConfig()</span><br><span class="line">  &#125;, seconds * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._configTimer.unref()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然轮询可怕，但上面已经为 Timeout 调用了 unref 方法。正常来说，只要没有其他 event loop 在运行，<code>Timer.unref()</code> 能够让 Node.js 进程在 Timeout 回调调用前退出，可以防止程序空转。</p><p>因此问题不在这段代码，为了验证推断，关闭此选项之后，果然依旧不能正常退出。</p><p>既然进程还在运转，就一定有其他的 event loop。在 elastic-apm-http-client 中继续寻找到了另一个 Timeout，该函数每次触发数据上报时都会被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Client.prototype._maybeCork = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._writableState.corked &amp;&amp; <span class="keyword">this</span>._conf.bufferWindowTime !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cork()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._corkTimer &amp;&amp; <span class="keyword">this</span>._corkTimer.refresh) &#123;</span><br><span class="line">      <span class="comment">// the refresh function was added in Node 10.2.0</span></span><br><span class="line">      <span class="keyword">this</span>._corkTimer.refresh()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._corkTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.uncork()</span><br><span class="line">      &#125;, <span class="keyword">this</span>._conf.bufferWindowTime)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._writableState.length &gt;= <span class="keyword">this</span>._conf.bufferWindowSize) &#123;</span><br><span class="line">    <span class="keyword">this</span>._maybeUncork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Timer.refresh()</code> 可以重置已执行的定时任务，这里很有可能是真正的问题点。</p><p>暂停代码阅读，先盲目猜测一波：在第一次请求超时之前，进程一定不会退出，但超时之后，将在 30 秒后才会重新发起新的请求，进程退出的机会就在这 30 秒。而 _maybeCork 这里虽然每次数据上报都会触发不经过 unref 处理的 setTimeout，奈何我查了 bufferWindowTime 默认才 20 毫秒。所以问题出在这里的可能性又很渺茫了，试下把这段注释掉，果然……<br>但凭着对 elastic-apm-node 项目的熟悉，性能指标的上报间隔恰好也是 30 秒，这里一定有个定时任务的，但之前直接在项目中搜索关键字未找到，就忽略了。</p><p>根据相关时间字段，又检索到了定时任务的创建地点 —— <code>measured-reporting</code> 模块，然而这里也做了 unref 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_createIntervalCallback(intervalInSeconds) &#123;</span><br><span class="line">  <span class="keyword">this</span>._log.debug(<span class="string">`_createIntervalCallback() called with intervalInSeconds: <span class="subst">$&#123;intervalInSeconds&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._reportMetricsWithInterval(intervalInSeconds);</span><br><span class="line">  &#125;, intervalInSeconds * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._unrefTimers) &#123;</span><br><span class="line">    timer.unref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._intervals.push(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="狩猎失败-超时"><a href="#狩猎失败-超时" class="headerlink" title="狩猎失败/超时"></a>狩猎失败/超时</h1><p>在 node_modules 中全局搜索了 setTimeout 以及 setInterval，排除了所有可疑迹象，剩下的连接就难排查了，迫于“生产力”，问题暂时追踪到这里。。。</p><h1 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h1><p>思考了对应的解决方案：</p><ol><li>将 ets 改成异步执行，但可能失去了前置检查的意义</li><li>分析并重写 elastic-apm-node 的连接机制</li><li>在 ets 执行时不启动 apm</li><li>做好连通性检测，确保 apm 的配置可靠再 apm.start()，但网络请求是异步的，会让 apm 之后整个项目的模块加载都在异步回调中处理</li></ol><p>1、2 的成本太高，而 4 没有做过可靠的测试，不保证不会对模块加载和优化产生副作用，所以最可行的方案是 3。</p><p>找准方向就开搞，通过 process.env 入手，关注几个比较有用的环境变量：</p><ol><li>process.env.NODE_ENV</li><li>process.env.ETS_REGISTER_PID，此变量存在时，证明有 ets 参与，不启动。但特别地，单独运行 <code>ets</code> 时没有此变量，也没有 NODE_ENV，应对方法是将 NODE_ENV 为 undefined 的环境也排除。</li><li>process.env.npm_lifecycle_event，是 npm 添加的当前执行的 npm script 名称标识。可以考虑为 start，restart 时才启动。</li></ol><p>补充方案：<br>通过 process.env 向 apm 传递自定义参数，便于控制配置项。</p><p>最后 apm 启动头部长这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 APM_ENABLE 作为开关条件</span></span><br><span class="line"><span class="keyword">const</span> enableAPM = process.env.APM_ENABLE || process.env.NODE_ENV || !process.env.ETS_REGISTER_PID;</span><br><span class="line"><span class="keyword">if</span> (enableAPM) &#123;</span><br><span class="line">  <span class="comment">// 除了 NODE_ENV，也可以使用自定义的 ENV</span></span><br><span class="line">  <span class="keyword">const</span> options = getOptionsByENV(process.env.NODE_ENV)</span><br><span class="line">  apm.start(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然没结论，但进程挂起的根本原因是没错的。找 BUG 最耗时的是方向歪了，试过用干净的 Node.js 代码模拟，没能复现问题。而 wtfnode 和其他跟踪模块，因为 callsite 覆盖问题，也没能提供清晰的调用栈，或许应该考虑从修复 callsite 这个方向入手？</p><p>To be continue? </p><p>但是意义不大了，从这堆充满 hack 的代码中并没有学到特别有价值的东西，而且时间成本太高。倒是警醒自己在 Timer 和 socket 的底层使用上，务必留意 unref 的处理。还是把时间留给更重要的事吧，衰！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先把干货放前面，辅助排查的 npm 模块有：&lt;a href=&quot;https://github.com/myndzi/wtfnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wtfnode&lt;/a&gt;，why-is-node-running，active-handles 等，使用方法差不多如下，可以查看各自的文档。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; wtf = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;wtfnode&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// your codes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// track down&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wtf.dump();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;也可以更深入地排查，因为上述模块的核心都是 Node.js 文档未标注的两个接口：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;process._getActiveHandles();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;process._getActiveRequests();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;好了，本篇到这里结束了，剩下的内容，劝你还是跳过吧：流水帐警告⚠️️ 翻车警告⚠️️&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>警惕 Travis CI 的 npm 缓存</title>
    <link href="https://claude-ray.github.io/2019/08/01/travis-npm-cache/"/>
    <id>https://claude-ray.github.io/2019/08/01/travis-npm-cache/</id>
    <published>2019-08-01T13:56:25.000Z</published>
    <updated>2019-08-01T15:17:12.726Z</updated>
    
    <content type="html"><![CDATA[<p>从 2019 年 7 月份开始，Travis CI 默认开启 npm 缓存。这意味着 node_module 和 package-lock.json 会在初次构建时缓存，倘若后续更新 npm 依赖而不刷新该缓存，可能带来构建失败的问题。</p><a id="more"></a><p>下面是发现问题的源头。</p><p>在为一个项目添加了新的依赖 rimraf 之后，Travis CI 意外地报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh: 1: rimraf: not found</span><br></pre></td></tr></table></figure><p>此时 <code>.travis.yml</code> 配置为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'8'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">i</span> <span class="string">npminstall</span> <span class="bullet">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npminstall</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">ci</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npminstall</span> <span class="string">codecov</span> <span class="string">&amp;&amp;</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p>很明显新增的 npm 依赖没有安装上，但本地测试没有问题，于是替换 npminstall 为原生的 npm install，降低问题排查范围。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'8'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">ci</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">codecov</span> <span class="string">&amp;&amp;</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p>然而移除 npminstall 之后，报错变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection RangeError: Maximum call stack size exceeded</span><br><span class="line">    at RegExp.test (&lt;anonymous&gt;)</span><br><span class="line">    at /home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/node_modules/aproba/index.js:38:16</span><br><span class="line">    at Array.forEach (&lt;anonymous&gt;)</span><br><span class="line">    at module.exports (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/node_modules/aproba/index.js:33:11)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:37:3)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (/home/travis/.nvm/versions/node/v8.16.0/lib/node_modules/npm/lib/install/flatten-tree.js:39:14)</span><br></pre></td></tr></table></figure><p>之后，去掉 rimraf 依赖于事无济，重跑其他 node 项目的 ci 却一切正常，因此最终确定是 travis 运行环境带来的问题。</p><p>果然，寻找刷新方法的过程中发现了右侧 <code>More options</code> 中的 <code>Caches</code> 选项，点击里面的删除键后，CI 重新运行成功。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.travis-ci.com/user/caching/#npm-cache" target="_blank" rel="noopener">https://docs.travis-ci.com/user/caching/#npm-cache</a></p><blockquote><p>Please note that as of July 2019, npm is cached by default on Travis CI</p></blockquote><p>To disable npm caching, use:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  npm:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 2019 年 7 月份开始，Travis CI 默认开启 npm 缓存。这意味着 node_module 和 package-lock.json 会在初次构建时缓存，倘若后续更新 npm 依赖而不刷新该缓存，可能带来构建失败的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="CI" scheme="https://claude-ray.github.io/categories/CI/"/>
    
    
      <category term="Travis" scheme="https://claude-ray.github.io/tags/Travis/"/>
    
      <category term="CI" scheme="https://claude-ray.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>fcitx-remote-for-osx 设置 Squirrel 输入法切换</title>
    <link href="https://claude-ray.github.io/2019/07/17/fcitx-remote-for-osx-squirrel/"/>
    <id>https://claude-ray.github.io/2019/07/17/fcitx-remote-for-osx-squirrel/</id>
    <published>2019-07-17T12:55:30.000Z</published>
    <updated>2019-07-17T12:57:29.543Z</updated>
    
    <content type="html"><![CDATA[<p>初衷是解决中文输入法在 vim/evil 键位下的 <code>insert</code> 模式和 <code>normal</code> 模式的切换问题，实现 <code>normal</code> 模式自动切英文、<code>insert</code> 模式回复之前的输入状态。</p><p>当然各编辑器都有各自知名的解决方案，本次主要吐槽 Mac 平台 fcitx-remote-for-osx 和 squirrel 输入法间的“摩擦”。</p><a id="more"></a><p>在读本篇之前，默认你已经按照 fcitx-remote-for-osx <a href="https://github.com/xcodebuild/fcitx-remote-for-osx" target="_blank" rel="noopener">文档</a>进行了相关操作，并最终遇到了切换失败的问题，否则下文将对你没有帮助。</p><p>本来文档中指定的安装方法很简单</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fcitx-remote-for-osx --with-input-method=&lt;method&gt;</span><br></pre></td></tr></table></figure><p>可是目前 homebrew 的 formula 移除了 options，无法指定 <code>--with-input-method</code>，上面指令的直接结果将是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: invalid option: --with-input-method=squirrel-rime</span><br></pre></td></tr></table></figure><p>最初参考这个 <a href="https://github.com/xcodebuild/fcitx-remote-for-osx/issues/38#issuecomment-468114160" target="_blank" rel="noopener">issue</a>，通过 brew cap 安装 fcitx-remote-for-osx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap codefalling/fcitx-remote-for-osx</span><br><span class="line">brew install codefalling/fcitx-remote-for-osx/fcitx-remote-for-osx --with-squirrel-rime</span><br></pre></td></tr></table></figure><p>但是安装版本太老，引发了新的问题，无论是在 terminal，还是在 vim、emacs、vscode 中，只能切换到英文，无法切回 squirrel。</p><blockquote><p>可以执行 <code>fcitx-remote -t</code> 来测试能否反复切换中英文输入法。</p></blockquote><p>这时候通过 fcitx-remote-for-osx 的 <a href="https://github.com/xcodebuild/fcitx-remote-for-osx/blob/master/build.py" target="_blank" rel="noopener">build</a> 文件，发现 squirrel 有两种 bundle identitier</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputMethod = &#123;</span><br><span class="line">    <span class="string">'squirrel-rime'</span>: <span class="string">'com.googlecode.rimeime.inputmethod.Squirrel.Rime'</span>,</span><br><span class="line">    <span class="string">'squirrel-rime-upstream'</span>: <span class="string">'im.rime.inputmethod.Squirrel.Rime'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看已安装rime的 Identifier</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osascript -e <span class="string">'id of app "squirrel"'</span></span><br></pre></td></tr></table></figure><p>结果可能是 <code>im.rime.*</code> 或 <code>com.googlecode.rimeime.*</code>。我这里的输出为 <code>im.rime.inputmethod.Squirrel</code>，说明要使用 <code>squirrel-rime-upstream</code> 作为编译选项。</p><p>可惜 tap 安装的旧版没有这个选项，最后决定直接用源码编译，等新版本修复了再回归 homebrew 管理。<code>build.py</code> 文件内容本来就简单，并且作者在 <a href="https://github.com/xcodebuild/fcitx-remote-for-osx/tree/feature/special-input-method#install" target="_blank" rel="noopener">special-input-method分支</a> 提供了编译安装的文档，效果和 homebrew install 是一致的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dangxuandev/fcitx-remote-for-osx</span><br><span class="line"><span class="built_in">cd</span> fcitx-remote-for-osx</span><br><span class="line">./build.py build squirrel-rime-upstream</span><br><span class="line">cp ./fcitx-remote-squirrel-rime-upstream /usr/<span class="built_in">local</span>/bin/fcitx-remote</span><br><span class="line">ln -snf /usr/<span class="built_in">local</span>/bin/fcitx-remote /usr/<span class="built_in">local</span>/bin/fcitx-remote-squirrel-rime</span><br></pre></td></tr></table></figure><p>基本可以正常使用了，也没有出现切换延迟较高的问题，但偶尔遇到 squirrel 卡住，无法切换中英，在 squirrel issues 可以看到了有许多相关 bug。但是并没有人给出终极的解决方案，佛振认为这是其他软件的问题，暂不予关注，等他参与修复可能遥遥无期。详见这个已关闭的 <a href="https://github.com/rime/squirrel/issues/292" target="_blank" rel="noopener">issue</a></p><p>在写这篇文章的过程中，就触发了一次卡死状态……但切换输入法、或切换窗口就可以恢复。而在 VSCode 配置 vim 插件的<a href="https://github.com/VSCodeVim/Vim#input-method" target="_blank" rel="noopener">自动切换</a>后 100% 重现。</p><p>毕竟中文输入场景很少，完美输入方案在个人看来是不存在的，也就不再多折腾它了，暂且容忍一段时间，等出现频率高了再找解决方案吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初衷是解决中文输入法在 vim/evil 键位下的 &lt;code&gt;insert&lt;/code&gt; 模式和 &lt;code&gt;normal&lt;/code&gt; 模式的切换问题，实现 &lt;code&gt;normal&lt;/code&gt; 模式自动切英文、&lt;code&gt;insert&lt;/code&gt; 模式回复之前的输入状态。&lt;/p&gt;
&lt;p&gt;当然各编辑器都有各自知名的解决方案，本次主要吐槽 Mac 平台 fcitx-remote-for-osx 和 squirrel 输入法间的“摩擦”。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://claude-ray.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="squirrel" scheme="https://claude-ray.github.io/tags/squirrel/"/>
    
      <category term="Vim" scheme="https://claude-ray.github.io/tags/Vim/"/>
    
      <category term="emacs evil" scheme="https://claude-ray.github.io/tags/emacs-evil/"/>
    
      <category term="input method" scheme="https://claude-ray.github.io/tags/input-method/"/>
    
  </entry>
  
  <entry>
    <title>elastic-apm-node 扩展篇 —— Egg</title>
    <link href="https://claude-ray.github.io/2019/07/12/elastic-apm-node-egg/"/>
    <id>https://claude-ray.github.io/2019/07/12/elastic-apm-node-egg/</id>
    <published>2019-07-12T13:18:53.000Z</published>
    <updated>2019-07-12T14:06:40.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇是为 elastic-apm-node 编写拓展系列的第二篇，主要介绍 egg 框架的定制指南。</p><p>单独拿 egg 出来讲，是因为市面主流的 APM 工具几乎都没有为 egg 提供支持。一方面 egg 底层基于 koa ，并且 egg-router 也是 koa-router 的二次封装，两者相似以致插件可以平稳切换，agent 的补丁方式也基本是一致的。另一方面，agent 代码必须早于 egg 和 egg-router 的加载才能生效，egg-bin、egg-script 等生态决定了编写框架之上的插件很难做到零代码入侵。</p><p>APM agent 作为 npm package 不适合做这样的事，更好的方法是我们利用 egg 工具链的接口，在引入 agent 的代码层处理好 egg 的配置。</p><a id="more"></a><h1 id="在-egg-前-require"><a href="#在-egg-前-require" class="headerlink" title="在 egg 前 require"></a>在 egg 前 require</h1><p>我们先考虑如何将 APM agent 早于 egg 执行，解决 patch 此框架主要问题，然后再完成定制化操作。</p><p>好在 egg 是提供了相关方法的，最底层的 API 是 <code>startCluster</code> 方法，可以传入 <code>require</code> 参数指明你要率先执行模块。</p><h2 id="方案一：修改启动文件"><a href="#方案一：修改启动文件" class="headerlink" title="方案一：修改启动文件"></a>方案一：修改启动文件</h2><p>假设把 APM 的引入和配置放在了根目录 elastic-apm.js 中，新建一个类似下面这样的 app.js 作为 egg 的启动文件，用最原始的 <code>node app.js</code> 启动服务就好了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'egg'</span>).startCluster(&#123;</span><br><span class="line">  <span class="built_in">require</span>: [ <span class="built_in">require</span>.resolve(<span class="string">'./elastic-apm'</span>) ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>!!! 不推荐：必须放弃 egg-bin 和 egg-scripts 作为启动器，需要自己补上很多操作。</p></blockquote><h2 id="方案二：修改-package-json"><a href="#方案二：修改-package-json" class="headerlink" title="方案二：修改 package.json"></a>方案二：修改 package.json</h2><blockquote><p>要求 <code>egg-bin</code> 版本 &gt;= <a href="https://github.com/eggjs/egg-bin/blob/master/History.md#4100--2019-01-04" target="_blank" rel="noopener">4.10.0</a></p></blockquote><p>在 <code>package.json</code> 中添加 <code>egg.require</code> 配置，用法来自 <a href="https://github.com/eggjs/egg/issues/2844#issuecomment-409457550" target="_blank" rel="noopener">issue 讨论</a>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"egg"</span>: &#123;</span><br><span class="line">    <span class="attr">"require"</span>: [ <span class="string">"./elastic-apm.js"</span> ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"egg-scripts start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是目前最推荐的做法，不影响 egg 工具链的正常使用。</p><h1 id="编写补丁"><a href="#编写补丁" class="headerlink" title="编写补丁"></a>编写补丁</h1><h2 id="instrumentation-egg-js"><a href="#instrumentation-egg-js" class="headerlink" title="instrumentation/egg.js"></a>instrumentation/egg.js</h2><p>仿照 <a href="https://github.com/elastic/apm-agent-nodejs/blob/master/lib/instrumentation/modules/koa.js" target="_blank" rel="noopener">instrumentation/koa.js</a>，修改框架 name，注意开启 overwrite 选项，为了覆盖引用 koa 带来的标识。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">egg, agent, &#123; version, enabled &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span> egg</span><br><span class="line">  <span class="comment">// 注意开启 overwrite，这样才能覆盖 koa 标识</span></span><br><span class="line">  agent.setFramework(&#123; <span class="attr">name</span>: <span class="string">'egg'</span>, version, <span class="attr">overwrite</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> egg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instrumentation-egg-router-js"><a href="#instrumentation-egg-router-js" class="headerlink" title="instrumentation/egg-router.js"></a>instrumentation/egg-router.js</h2><p>唯一需要修改的就是去掉 <a href="https://github.com/elastic/apm-agent-nodejs/blob/master/lib/instrumentation/modules/koa-router.js" target="_blank" rel="noopener">instrumentation/koa-router.js</a> 的版本验证。考虑到 egg 引入的 koa 版本都是同时期最新，无须担心 egg 自身版本问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shimmer = <span class="built_in">require</span>(<span class="string">'elastic-apm-node/lib/instrumentation/shimmer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">Router, agent, &#123; version, enabled &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span> Router</span><br><span class="line"></span><br><span class="line">  agent.logger.debug(<span class="string">'shimming koa-router prototype.match function'</span>)</span><br><span class="line">  shimmer.wrap(Router.prototype, <span class="string">'match'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">orig</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_, method</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> matched = orig.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> method !== <span class="string">'string'</span>) &#123;</span><br><span class="line">        agent.logger.debug(<span class="string">'unexpected method type in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> method)</span><br><span class="line">        <span class="keyword">return</span> matched</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(matched &amp;&amp; matched.pathAndMethod)) &#123;</span><br><span class="line">        <span class="keyword">const</span> layer = matched.pathAndMethod.find(<span class="function"><span class="keyword">function</span> (<span class="params">layer</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> layer &amp;&amp; layer.opts &amp;&amp; layer.opts.end === <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> path = layer &amp;&amp; layer.path</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> name = method + <span class="string">' '</span> + path</span><br><span class="line">          agent._instrumentation.setDefaultTransactionName(name)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          agent.logger.debug(<span class="string">'unexpected path type in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> path)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        agent.logger.debug(<span class="string">'unexpected match result in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> matched)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> matched</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加补丁"><a href="#添加补丁" class="headerlink" title="添加补丁"></a>添加补丁</h1><p>回到最初的 elastic-apm.js 文件，在其中设置 addPatch，大功告成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> apm = <span class="built_in">require</span>(<span class="string">'elastic-apm-node'</span>).start(&#123;</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">apm.addPatch(<span class="string">'egg'</span>, <span class="built_in">require</span>.resolve(<span class="string">'./instrumentation/egg'</span>))</span><br><span class="line">apm.addPatch(<span class="string">'@eggjs/router'</span>, <span class="built_in">require</span>.resolve(<span class="string">'./instrumentation/egg-router'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇是为 elastic-apm-node 编写拓展系列的第二篇，主要介绍 egg 框架的定制指南。&lt;/p&gt;
&lt;p&gt;单独拿 egg 出来讲，是因为市面主流的 APM 工具几乎都没有为 egg 提供支持。一方面 egg 底层基于 koa ，并且 egg-router 也是 koa-router 的二次封装，两者相似以致插件可以平稳切换，agent 的补丁方式也基本是一致的。另一方面，agent 代码必须早于 egg 和 egg-router 的加载才能生效，egg-bin、egg-script 等生态决定了编写框架之上的插件很难做到零代码入侵。&lt;/p&gt;
&lt;p&gt;APM agent 作为 npm package 不适合做这样的事，更好的方法是我们利用 egg 工具链的接口，在引入 agent 的代码层处理好 egg 的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="APM" scheme="https://claude-ray.github.io/tags/APM/"/>
    
      <category term="Elastic-APM" scheme="https://claude-ray.github.io/tags/Elastic-APM/"/>
    
      <category term="Egg" scheme="https://claude-ray.github.io/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>elastic-apm-node 扩展篇 —— Express</title>
    <link href="https://claude-ray.github.io/2019/07/11/elastic-apm-node-express/"/>
    <id>https://claude-ray.github.io/2019/07/11/elastic-apm-node-express/</id>
    <published>2019-07-11T14:54:59.000Z</published>
    <updated>2019-07-12T14:06:48.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>elastic-apm-node 提供了非常友好的定制化支持，本篇将示范如何为 express 框架添加路由 patch，以满足信息上报的优化。</p><a id="more"></a><p>许多开发者在定制开源依赖时，都选择了 fork 源码，在此基础上提交修改，作为新的模块来“维护”。这样做的稳定性极高，等于对依赖加上了版本锁，不用担心动态版本的安全问题。</p><p>但弊端也非常大，最重要的是需要投入精力定时跟进官方包的更新。除了要小心 <code>breaking change</code>，任何你需要的 <code>fix</code> 或 <code>feature</code>，都要重新更新发布自己的模块。维护成本极高，甚至大部分情况是没人维护的。</p><p>幸亏 elastic-apm-node 有不错的扩展性，我们不用 fork，只需要做一个包裹层二次封装。</p><p>定制的出发点要立在合理的需求上，我们拿 vue-ssr 官网的 demo 举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = <span class="built_in">require</span>(<span class="string">'/path/to/built-server-bundle.js'</span>)</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123; <span class="attr">url</span>: req.url &#125;</span><br><span class="line"></span><br><span class="line">  createApp(context).then(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">    renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err.code === <span class="number">404</span>) &#123;</span><br><span class="line">          res.status(<span class="number">404</span>).end(<span class="string">'Page not found'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(html)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，无论请求 url 是指向哪个页面路由，Kibana apm 界面看到的事务信息永远都是 <code>GET *</code>，显然无法满足我们观测请求量的需要。</p><h1 id="route"><a href="#route" class="headerlink" title="route *"></a>route <code>*</code></h1><p>路由是 * 动态匹配的，要想获取到真实路由，比较容易的方案是读取 <code>req.path</code>，但最好的方案是直接拿到原始表达式，这样 <code>/user/:id</code> 形式的路由也能较好地折叠呈现。</p><p>但 vue ssr 项目通常将页面路由规则存放在前端，这种情况也无法在 express 的 router 上做文章，只能回到原始的 url path 方案了。</p><p>在 <code>node_modules/elastic-apm-node/lib/instrumentation/modules/express.js</code> 的 <code>patchLayer</code> 中加入如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> add below this code block</span></span><br><span class="line"><span class="keyword">if</span> (!layer.route &amp;&amp; layerPath &amp;&amp; <span class="keyword">typeof</span> next === <span class="string">'function'</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> patch route * up</span></span><br><span class="line"><span class="keyword">if</span> (layer.route &amp;&amp; layerPath === <span class="string">'*'</span> &amp;&amp; layer.path) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = req.method + <span class="string">' '</span> + layer.path</span><br><span class="line">  agent._instrumentation.setDefaultTransactionName(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以对 path 内部加上正则校验，遇到纯数值、32 位或 16 位定长 id，便将其当作 <code>:id</code>，将内容掩盖处理，以达成简易的路由还原效果。</p><p>最后，由于这个已经修改了 express route 的 wrap，但 shimmer 的代码决定了一个函数只能有一个 wrapper。因此想替换掉原有的 wrapper，必须先 unwrap express 的 route，然后再执行 shimmer.wrap 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> rewarp express router</span></span><br><span class="line">shimmer.unwrap(routerProto, <span class="string">'route'</span>)</span><br><span class="line"></span><br><span class="line">shimmer.wrap(routerProto, <span class="string">'route'</span>, orig =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> route = orig.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">var</span> layer = <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">    patchLayer(layer, path)</span><br><span class="line">    <span class="keyword">return</span> route</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他的 patch 同理。</p><h1 id="addPatch"><a href="#addPatch" class="headerlink" title="addPatch"></a>addPatch</h1><p>上面介绍了完成需求的方法，但本篇主旨是扩展，而非在源码上直接修改。这就要使用 apm agent 暴露的 <a href="https://www.elastic.co/guide/en/apm/agent/nodejs/master/agent-api.html#apm-add-patch" target="_blank" rel="noopener">addPatch</a> 接口。可在此基础上完成所有定制框架和路由的处理。</p><p>特别提示，有别于上面的 wrapper，针对同一个 npm 模块，elastic-apm-node 支持添加多个 patch。因此不必要的时候，无需删除 elastic agent 已经添加的 patch，直接在引入 apm 的地方调用 addPatch 即可。</p><p>还是以 express 为例，把 patch 的新方法写在另一个 <code>instrumentation/express.js</code> 文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apm = <span class="built_in">require</span>(<span class="string">'elastic-apm-node'</span>).start()</span><br><span class="line"></span><br><span class="line">apm.addPatch(<span class="string">'express'</span>, <span class="built_in">require</span>.resolve(<span class="string">'./instrumentation/express'</span>))</span><br></pre></td></tr></table></figure><p>./instrumentation/express.js 的实现可以参考原 agent v2.12.1 版本中的 <a href="https://github.com/elastic/apm-agent-nodejs/blob/master/lib/instrumentation/modules/express.js" target="_blank" rel="noopener">express</a>，需要修改的内容上文已经提到了，需要补充代码的位置参考如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Original file: https://github.com/elastic/apm-agent-nodejs/blob/master/lib/instrumentation/modules/express.js</span></span><br><span class="line"><span class="comment">// License: https://github.com/elastic/apm-agent-nodejs/blob/master/LICENSE</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isError = <span class="built_in">require</span>(<span class="string">'core-util-is'</span>).isError</span><br><span class="line"><span class="keyword">const</span> semver = <span class="built_in">require</span>(<span class="string">'semver'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具模块直接引用 agent，不必重复实现</span></span><br><span class="line"><span class="keyword">const</span> shimmer = <span class="built_in">require</span>(<span class="string">'elastic-apm-node/lib/instrumentation/shimmer'</span>)</span><br><span class="line"><span class="keyword">const</span> symbols = <span class="built_in">require</span>(<span class="string">'elastic-apm-node/lib/symbols'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余未经标注的代码均来自原 agent 的 express 文件，只需要复制必要的部分</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">express, agent, &#123; version, enabled &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 框架识别、版本号校验、路由兼容性的一些处理，以及内部函数，从文件原样复制即可</span></span><br><span class="line">  <span class="comment">// 省略代码若干行……</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">patchLayer</span> (<span class="params">layer, layerPath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!layer[layerPatchedSymbol]) &#123;</span><br><span class="line">      layer[layerPatchedSymbol] = <span class="literal">true</span></span><br><span class="line">      agent.logger.debug(<span class="string">'shimming express.Router.Layer.handle function:'</span>, layer.name)</span><br><span class="line">      shimmer.wrap(layer, <span class="string">'handle'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">orig</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> handle</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (orig.length !== <span class="number">4</span>) &#123;</span><br><span class="line">          handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!layer.route &amp;&amp; layerPath &amp;&amp; <span class="keyword">typeof</span> next === <span class="string">'function'</span>) &#123;</span><br><span class="line">              safePush(req, symbols.expressMountStack, layerPath)</span><br><span class="line">              <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(req.route &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="built_in">Error</span>)) &#123;</span><br><span class="line">                  req[symbols.expressMountStack].pop()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> next.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> 在这里添加 `*` 等路由定制代码</span></span><br><span class="line">            <span class="keyword">if</span> (layer.route &amp;&amp; layerPath === <span class="string">'*'</span> &amp;&amp; layer.path) &#123;</span><br><span class="line">              <span class="keyword">const</span> name = req.method + <span class="string">' '</span> + layer.path</span><br><span class="line">              agent._instrumentation.setDefaultTransactionName(name)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> orig.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 省略若干行……</span></span><br><span class="line">        <span class="keyword">return</span> handle</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略若干行……</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 记得加一行 unwrap</span></span><br><span class="line">  shimmer.unwrap(routerProto, <span class="string">'route'</span>)</span><br><span class="line">  <span class="comment">// 并重新 wrap，代码复制过来即可</span></span><br><span class="line">  shimmer.wrap(routerProto, <span class="string">'route'</span>, orig =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> route = orig.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">var</span> layer = <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">      patchLayer(layer, path)</span><br><span class="line">      <span class="keyword">return</span> route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 剩余代码处理基本到此位置了，不需要处理的 wrapper 保持不动就好</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> express</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unknown-route"><a href="#unknown-route" class="headerlink" title="unknown route"></a>unknown route</h1><p>在使用中发现，通过 app.use 引入的路由全部被标记为 <code>unknown route</code>，正准备在 patch 中修复这个问题的时候，在这个 <a href="https://github.com/elastic/apm-agent-nodejs/issues/1008" target="_blank" rel="noopener">issue</a> 中找到了根源。</p><p>此问题在 <code>v2.11.5</code> 版本后修复，升级版本就行，不用折腾了~</p><h1 id="Afterword"><a href="#Afterword" class="headerlink" title="Afterword"></a>Afterword</h1><p>给 elastic-apm-node 编写拓展时明显体会到高扩展性的优势。在设计工具类时，良好的扩展性给用户带来了非常多的便利，遇到这类第三方依赖的 bug 时，作为用户的我们可以在 <strong>不修改原始代码的情况下自行将其修复</strong>。</p><p>特别是近期接触了较多 GNU 精神，向所有在项目中为扩展性挥洒汗水的开发者致敬。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;elastic-apm-node 提供了非常友好的定制化支持，本篇将示范如何为 express 框架添加路由 patch，以满足信息上报的优化。&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://claude-ray.github.io/tags/Express/"/>
    
      <category term="APM" scheme="https://claude-ray.github.io/tags/APM/"/>
    
      <category term="Elastic-APM" scheme="https://claude-ray.github.io/tags/Elastic-APM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT 主题升级</title>
    <link href="https://claude-ray.github.io/2019/06/28/hexo-theme-next-upgrade-7/"/>
    <id>https://claude-ray.github.io/2019/06/28/hexo-theme-next-upgrade-7/</id>
    <published>2019-06-28T14:58:34.000Z</published>
    <updated>2019-06-28T16:01:05.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>苦于 <code>hexo g</code> 的效率问题，与其重新折腾框架，决定在彻底忍受不了之前再实行一点儿补救措施——依赖升级。</p><p>Hexo 主题 NexT 5.1.x 已经很久不维护，传说新版本 7.1.x 的速度有显著提升，它是本次的重点升级对象。这里只记录 Next 主题的变更，因为 Hexo 主体和其他依赖的升级都十分平滑，没有明显的 breaking changes。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>参考 <a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md" target="_blank" rel="noopener">5.1.x升级指南</a>，问题不大，主要痛点在于忘了曾经做过哪些定制的改动，再次提醒自己 init 和 custom 提交区分开的重要性。</p><p>直接在博客根目录执行 git clone，把最新版主题放到 next7 下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next7</span><br></pre></td></tr></table></figure><p>为了清理 NexT 仓库原有的 git 信息，继续执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next7 &amp;&amp; rm -rf .git &amp;&amp; git rm --cache . -f</span><br></pre></td></tr></table></figure><h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>在站点 _config.yml 中替换主题为 next7，便成功替换到新主题。启动站点之前，先参考迁移文档把主题下定制过的样式复制过来（以及其他曾经定制过的文件）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#theme: next</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next7</span></span><br></pre></td></tr></table></figure><h1 id="主要配置"><a href="#主要配置" class="headerlink" title="主要配置"></a>主要配置</h1><ol><li><p>favicon，记得把图片也拷贝到新主题目录</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line"><span class="attr">  small:</span> <span class="string">/images/favicon.ico</span> <span class="comment">#/images/favicon-16x16-next.png</span></span><br><span class="line"><span class="attr">  medium:</span> <span class="string">/images/favicon.ico</span> <span class="comment">#/images/favicon-32x32-next.png</span></span><br><span class="line"><span class="attr">  apple_touch_icon:</span> <span class="string">/images/favicon.ico</span> <span class="comment">#/images/apple-touch-icon-next.png</span></span><br><span class="line"><span class="attr">  safari_pinned_tab:</span> <span class="string">/images/favicon.ico</span> <span class="comment">#/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure></li><li><p>footer，如果觉得主题信息冗余，可以 false 去掉</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line"><span class="attr">  since:</span> <span class="number">2017</span> <span class="comment"># 站点起始日期</span></span><br><span class="line"><span class="attr">  icon:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">bolt</span> <span class="comment"># 替换footer中的图标</span></span><br><span class="line"><span class="attr">  powered:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  theme:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>creative_commons，打开许可协议</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">by-nc-sa</span></span><br><span class="line"><span class="attr">  sidebar:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  language:</span></span><br></pre></td></tr></table></figure></li><li><p>menu，和 next 5 略有不同，icon 的设置和目录放在一起了，按需开启</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></li><li><p>scheme 切换，和 next 5 一样的配置姿势</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br></pre></td></tr></table></figure></li><li><p>social，同 menu</p></li><li><p>links 友链，和之前相比也没什么变化</p></li><li><p>avatar，默认可以设置圆角和旋转了，好评</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line"><span class="attr">  rounded:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  rotated:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  animation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>symbols_count_time。这个算是 next 性能优化的一大“改进”。按作者的描述，其性能比 <code>hexo-wordcount</code> 好，效果比 <code>hexo-reading-time</code> 强（主要强在支持字数统计？）。</p><p> 可惜性能上去了，准确度堪忧，3k 字的文章被统计成了 8k 字，看源码似乎是标点也统计进去了，修改了 awl (Average Word Length) 也没解决问题，这让我接受不能。同时还与 NexT 主题存在版本不兼容的<a href="https://github.com/theme-next/hexo-symbols-count-time/issues/31" target="_blank" rel="noopener">问题</a>。</p><p> 顺便瞅了眼 hexo-wordcount 的源码，并不存在 NexT 升级文档上描述的“存在外部依赖”问题，因为作者在此之后进行了整改，目前代码量也非常小。并且在亲自对比生成静态文件的速度后……打扰了，果然还是 hexo-wordcount 香。</p><p> 最终，套用了 NexT 内置的 symbols_count_time 模板，参考着 hexo-wordcount 的<a href="https://github.com/willin/hexo-wordcount/blob/master/README.md" target="_blank" rel="noopener">文档</a>把它重新装回来了！有兴趣更改的小伙伴，可以参考我的这次<a href="https://github.com/Claude-Ray/claude-ray.github.io/commit/c7caef597aff31f9eb5b1107672f539ca96c3d53" target="_blank" rel="noopener">提交</a>。</p></li></ol><ol start="9"><li>字数统计。这里笔者选择了关闭，原本 Leancloud 用着好好的，但最近发出公告，必须通过认证才能继续使用服务，懒得手持身份证去审核，于是考虑迁移到国际版。但经过一番尝试，国际版的 app id 无法直接用于替换。由于没有对博客做过宣传，这个阅读量对自己或别人的参考价值不大，因此放弃接入。:)</li></ol><h2 id="附-hexo-wordcount-的配置"><a href="#附-hexo-wordcount-的配置" class="headerlink" title="附 hexo-wordcount 的配置"></a>附 hexo-wordcount 的配置</h2><h3 id="themes-next7-config-yml"><a href="#themes-next7-config-yml" class="headerlink" title="themes/next7/_config.yml"></a>themes/next7/_config.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="themes-next7-layout-macro-post-swig"><a href="#themes-next7-layout-macro-post-swig" class="headerlink" title="themes/next7/layout/_macro/post.swig"></a>themes/next7/layout/_macro/post.swig</h3><p>busuanzi_count 模板下添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;# Custom word count with hexo-wordcount #&#125;</span><br><span class="line">&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;div class=&quot;post-wordcount&quot;&gt;</span><br><span class="line">    &#123;% if theme.post_wordcount.wordcount %&#125;</span><br><span class="line">      &#123;% if not theme.post_wordcount.separated_meta %&#125;</span><br><span class="line">        &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-file-word-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">        &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;symbols_count_time.count&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      &lt;span title=&quot;&#123;&#123; __(&apos;symbols_count_time.count&apos;) &#125;&#125;:&quot;&gt;</span><br><span class="line">        &#123;&#123; wordcount(post.content) &#125;&#125;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if theme.post_wordcount.min2read %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">        &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;symbols_count_time.time&apos;) &#125;&#125; &amp;asymp;&lt;/span&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      &lt;span title=&quot;&#123;&#123; __(&apos;symbols_count_time.time&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; min2read(post.content) &#125;&#125; mins.</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;# Custom word count with hexo-wordcount #&#125;</span><br></pre></td></tr></table></figure><h3 id="themes-next7-layout-partials-footer-swig"><a href="#themes-next7-layout-partials-footer-swig" class="headerlink" title="themes/next7/layout/_partials/footer.swig"></a>themes/next7/layout/_partials/footer.swig</h3><p>symbols_count_time 下面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;# Custom word count with hexo-wordcount #&#125;</span><br><span class="line">&#123;% if theme.post_wordcount.totalcount %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-area-chart&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;symbols_count_time.count_total&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;span title=&quot;&#123;&#123; __(&apos;symbols_count_time.count_total&apos;) &#125;&#125;&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; totalcount(site) &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;# Custom word count with hexo-wordcount #&#125;</span><br></pre></td></tr></table></figure><h3 id="themes-next7-source-css-common-components-post-post-meta-styl"><a href="#themes-next7-source-css-common-components-post-post-meta-styl" class="headerlink" title="themes/next7/source/css/_common/components/post/post-meta.styl"></a>themes/next7/source/css/_common/components/post/post-meta.styl</h3><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom word count with hexo-wordcount</span></span><br><span class="line"><span class="selector-class">.post-wordcount</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> !hexo-config(<span class="string">'post_wordcount.separated_meta'</span>) &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>升级过程比预想中的还要折腾，并且没有达到性能优化的目的，5.1.x 的稳定用户没有必要升级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;苦于 &lt;code&gt;hexo g&lt;/code&gt; 的效率问题，与其重新折腾框架，决定在彻底忍受不了之前再实行一点儿补救措施——依赖升级。&lt;/p&gt;
&lt;p&gt;Hexo 主题 NexT 5.1.x 已经很久不维护，传说新版本 7.1.x 的速度有显著提升，它是本次的重点升级对象。这里只记录 Next 主题的变更，因为 Hexo 主体和其他依赖的升级都十分平滑，没有明显的 breaking changes。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://claude-ray.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://claude-ray.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Node.js APM 产品调研：Elastic APM</title>
    <link href="https://claude-ray.github.io/2019/05/27/elastic-apm-node-research/"/>
    <id>https://claude-ray.github.io/2019/05/27/elastic-apm-node-research/</id>
    <published>2019-05-27T14:46:05.000Z</published>
    <updated>2019-07-30T08:42:35.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据上一篇《<a href="https://claude-ray.github.io/2019/05/19/node-apm-product-research/">Node.js APM 产品调研</a>》的市场调研结果，笔者更青睐 Elastic APM 这个开源产品，故决定带来它的一篇专题介绍。</p><p>尽管团队已经开始试用，但踩坑时间较短，与其编写测评，不如先带大家走进这个项目，剖析个别令人感兴趣的技术点。</p><a id="more"></a><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>从 github 的信息来看，项目从 2011 年 11 月开工，已经不算新项目，期间基本就是单人维护的状态，进展到现在颇为不易。</p><p>两任作者分别是 Sentry 的核心成员 Matt Robenolt，以及 Elastic 团队的 Node.js 专职开发 Thomas Watson，同时他也是 Node.js 团队的核心贡献者之一。</p><p>对 Elastic APM 完全没有接触过的读者，可以先阅读 nswbmw/node-in-debugging 中的<a href="https://github.com/nswbmw/node-in-debugging/blob/master/5.2%20Elastic%20APM.md" target="_blank" rel="noopener">介绍</a>。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>官方文档是相当细致了，使用前推荐阅读。除了基本功能，这里列举一些值得关注的点</p><ul><li>支持自定义 Node 框架和路由。Agent 记录路由的原理都是 patch 各路由中间件的 match 方法，倘若 SDK 没有对你在用的路由库提供支持，可以选择手动记录或自行 patch。</li><li>支持主动上报错误 stack，并且帮你在看板上定位异常的来源代码。</li><li>支持采集 http 请求的 body 参数，默认关闭。一旦开启，可以构成非常强大的日志分析。但不建议在 apm agent 做这种处理，会给监控赋予了太多职能，有需要最好结合全链路 tracing 方案使用额外的 logger agent。</li><li>过滤敏感信息，根据请求头、或自定义维度。</li><li>支持定制 Transaction, Span， 额外的 custom 数据。</li><li>性能优化指南，结合自身业务需要，调整采样率、上报频率、请求体的限制。</li><li>支持 opentracing</li><li>支持 kubernetes</li></ul><h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p>首先我们简称 Elastic APM client 为 agent。agent 到日志采集服务 apm-server 的通讯方式为 http 或 https。请求方法被封装到了 <code>elastic-http-client</code> 模块，负责将 Transaction, Error, Metric, Span 这类指标发送到 apm-server，并且还包含格式检查、过长的信息截断的功能。</p><p>apm-server 负责将采集到的数据存储到 Elasticsearch。</p><p>最终在 Kibana 可视化地分析 Elasticsearch 中存储的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elastic-apm-node(node)  ➡   apm-server(golang)</span><br><span class="line">                                   ⬇</span><br><span class="line">     kibana(展示层)      ➡   elasticsearch(数据层)</span><br></pre></td></tr></table></figure><blockquote><p>数据全部由自己的 Elasticsearch 掌控，在此基础上能定制出更多分析工具。</p></blockquote><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>相比商业 APM 项目，elastic-apm-node 结构非常简洁。</p><p>基本的目录信息如下</p><ul><li>lib<ul><li>filters</li><li>instrumentation<ul><li>module</li></ul></li><li>metrics<ul><li>platform</li></ul></li><li>middleware</li></ul></li></ul><p>除了 filters 和 middleware 服务于内部功能，分别用于过滤敏感请求头(auth、cookie) 和异常捕获，剩下的就是核心功能  <code>Transaction</code>、<code>Error</code>、<code>Metric</code> 所在目录了。</p><p>接下来，我将围绕这三大功能进行介绍。</p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>通常错误日志包含了哪一行代码报错，但只有翻看代码才能确认究竟哪段代码出现问题。APM 提供了可以在看板界面直接确认异常代码的解决方案。</p><p>核心代码如下，目的是为了在 Error 对象中通过 __error_callsites 属性获取到 callsites 信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formatter = <span class="built_in">require</span>(<span class="string">'./lib/node-0.10-formatter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orig = <span class="built_in">Error</span>.prepareStackTrace</span><br><span class="line"><span class="built_in">Error</span>.prepareStackTrace = <span class="function"><span class="keyword">function</span> (<span class="params">err, callsites</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(err, <span class="string">'__error_callsites'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: callsites</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (orig || formatter)(err, callsites)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  err.stack</span><br><span class="line">  <span class="keyword">return</span> err.__error_callsites</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中只有一个不常见的方法 <code>Error.prepareStackTrace</code>，并且在 Node.js 的 API 中找不到，因为它实际是 V8 暴露的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>.prepareStackTrace(error, structuredStackTrace)</span><br></pre></td></tr></table></figure><p>这个接口常常被用来格式化错误信息，<code>structuredStackTrace</code> 包含了一组 CallSite 对象，CallSite 对象支持的方法有：getThis, getTypeName, getFunction, getFunctionName, getMethodName, getFileName, getLineNumber, getColumnNumber, getEvalOrigin, isToplevel, isEval, isNative, isConstructor, isAsync, isPromiseAll, getPromiseIndex</p><p>因此借助 CallSite 可以拿到 Error 抛出的文件、行列位置。</p><ul><li><code>getFileName</code>: if this function was defined in a script returns the name of the script</li><li><code>getLineNumber</code>: if this function was defined in a script returns the current line number</li><li><code>getColumnNumber</code>: if this function was defined in a script returns the current column number</li></ul><p>最后通过 <code>source-map</code> 模块的缓存，获取执行前后的代码。</p><p>处理 Error stack 的意义对 JS 直接编写的项目意义可能不是那么大，但假如开发者使用了 TS、或其他原因使生产环境的代码经过了一定编译，这时直接抛出的 Error stack 信息对开发者相当不友好。特定场景下 source-map 的代码映射变得至关重要。</p><p>默认地，Elastic APM 只记录 uncaughtException 和一小部分内部 patch 代码的错误。如果有较强的查错需求，得主动在业务中调用 <code>agent.captureError</code> 方法记录异常。</p><p>另外，若项目有特殊异常上报等原因需要监听 uncaughtException 事件，<strong>应当在 agent start() <code>之后</code>覆盖 <a href="https://www.elastic.co/guide/en/apm/agent/nodejs/current/agent-api.html#apm-handle-uncaught-exceptions" target="_blank" rel="noopener">agent.handleUncaughtExceptions</a> 方法</strong>，这样才能使其默认的捕获后 process.exit 的处理失效，以免进程在任务执行结束之前被 APM 的监听器强制退出。用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apm = <span class="built_in">require</span>(<span class="string">'elastic-apm-node'</span>).start()</span><br><span class="line">apm.handleUncaughtExceptions(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do your own stuff... and then exit:</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 handleUncaughtExceptions 在 start 之前调用，会被重新覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Agent.prototype.handleUncaughtExceptions = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> agent = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._uncaughtExceptionListener) &#123;</span><br><span class="line">    process.removeListener(<span class="string">'uncaughtException'</span>, <span class="keyword">this</span>._uncaughtExceptionListener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._uncaughtExceptionListener = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    agent.logger.debug(<span class="string">'Elastic APM caught unhandled exception: %s'</span>, err.message)</span><br><span class="line">    agent.captureError(err, &#123; <span class="attr">handled</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      cb ? cb(err) : process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">this</span>._uncaughtExceptionListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h2><p>一般来说，Node.js 原生暴露的接口足够对进程性能的基本状况有所判断了，但 APM 系统总是希望监控更详细的信息。</p><p>尤其是系统 CPU、内存占用率的走势图，原生 API 获取到的信息仍需要一定的计算工作。在简洁和效率的取舍上，一部分探针选择用纯 JS 计算，另一部分探针选择使用 C++ 获取/计算。使用 C++ 的库一般还会获取更复杂的指标，如 <a href="https://github.com/RuntimeTools/appmetrics" target="_blank" rel="noopener">appmetrics</a> 会获取一部分 GC、Event loop 信息（然而 GC 耗费占比的监控在 Node.js Runtime 下无法实现，信息来自：<a href="https://www.zhihu.com/question/315261661/answer/637417008" target="_blank" rel="noopener">关于Nodejs的性能监控思考？ - hyj1991的回答 - 知乎</a>）</p><p>Elastic APM 是相对小清新的一派，它选择纯 JS 实现，只针对 Linux 环境进行优化。如果发现当前服务环境 <code>process.platform</code> 是 Linux，它会从 /proc/ 目录定时获取系统性能快照，以降低计算量。如果是其他系统，再使用 JS 通过算法计算。</p><blockquote><p>实际上 Node.js 的底层 <code>libuv</code> 就是靠读取 proc 文件来采集 Linux 相关信息的。关于 proc 的介绍可以阅读 Linux 文件系统文档 <a href="https://github.com/torvalds/linux/blob/master/Documentation/filesystems/proc.txt" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/Documentation/filesystems/proc.txt</a></p></blockquote><ul><li>/proc/meminfo: 记录系统内存信息，用来获取两个指标：MemAvailable 和 MemTotal。对应 <code>os.totalmem()</code> 和 <code>os.freemem()</code>。</li><li>/proc/stat: 记录 CPU 活动信息，用来获取两个指标：cpuTotal 和 cpuUsage。这一步用 Node.js 计算略麻烦，需要定时缓存 <code>os.cpus()</code> 的 <code>times.total</code> <code>times.idle</code>指标。</li><li>/proc/self/stat: 不同于前面两个记录系统级信息的文件，此文件记录了当前进程的所有活动信息。可以用来获取进程 CPU、内存使用状况。原本 CPU 使用率需要除法运算，对应 <code>process.cpuUsage([previousValue])</code>，<code>process.hrtime([time])</code>，而通过此文件可以简化为加减法运算。获取的内存数据也可以用来计算 <code>process.memoryUsage().rss</code>，不过还是直接使用 Node.js 的 API 更简单。</li></ul><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><p>Elastic APM 中的事务，类似于 opentracing 中的 Span，但把一个请求中所有的 Span 抽象为一个概念。</p><p>Transaction 实现的基础是各种代码钩子。</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>通过 patch ，做一些信息采集，例如 Koa 框架的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">koa, agent, &#123; version, enabled &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled) <span class="keyword">return</span> koa</span><br><span class="line"></span><br><span class="line">  agent.setFramework(&#123; <span class="attr">name</span>: <span class="string">'koa'</span>, version, <span class="attr">overwrite</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> koa</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">shimmer.wrap(Router.prototype, <span class="string">'match'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_, method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> matched = orig.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> method !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      agent.logger.debug(<span class="string">'unexpected method type in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> method)</span><br><span class="line">      <span class="keyword">return</span> matched</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(matched &amp;&amp; matched.pathAndMethod)) &#123;</span><br><span class="line">      <span class="keyword">const</span> layer = matched.pathAndMethod.find(<span class="function"><span class="keyword">function</span> (<span class="params">layer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> layer &amp;&amp; layer.opts &amp;&amp; layer.opts.end === <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> path = layer &amp;&amp; layer.path</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = method + <span class="string">' '</span> + path</span><br><span class="line">        agent._instrumentation.setDefaultTransactionName(name)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        agent.logger.debug(<span class="string">'unexpected path type in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> path)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      agent.logger.debug(<span class="string">'unexpected match result in koa-router prototype.match: %s'</span>, <span class="keyword">typeof</span> matched)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matched</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 patch 配合 <code>require-in-the-middle</code> 模块，完成了对各框架的包装。</p><h3 id="async-hook"><a href="#async-hook" class="headerlink" title="async-hook"></a>async-hook</h3><p>利用 async-hook 实现记录整串请求，来看两个代码片段。</p><p>首先是基于 async-hook 封装了 Instrumentation 的 <code>currentTransaction</code> 方法，使异步操作中随时可以拿到当前 async scope id 下的 Transaction 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncHooks = <span class="built_in">require</span>(<span class="string">'async_hooks'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">ins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncHook = asyncHooks.createHook(&#123; init, before, destroy &#125;)</span><br><span class="line">  <span class="keyword">const</span> contexts = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activeTransactions = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(ins, <span class="string">'currentTransaction'</span>, &#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">      <span class="keyword">const</span> asyncId = asyncHooks.executionAsyncId()</span><br><span class="line">      <span class="keyword">return</span> activeTransactions.get(asyncId) || <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set (trans) &#123;</span><br><span class="line">      <span class="keyword">const</span> asyncId = asyncHooks.executionAsyncId()</span><br><span class="line">      <span class="keyword">if</span> (trans) &#123;</span><br><span class="line">        activeTransactions.set(asyncId, trans)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activeTransactions.delete(asyncId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 currentTransaction 的一处应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.prototype.bindFunction = <span class="function"><span class="keyword">function</span> (<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> original !== <span class="string">'function'</span> || original.name === <span class="string">'elasticAPMCallbackWrapper'</span>) <span class="keyword">return</span> original</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ins = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> trans = <span class="keyword">this</span>.currentTransaction</span><br><span class="line">  <span class="keyword">var</span> span = <span class="keyword">this</span>.currentSpan</span><br><span class="line">  <span class="keyword">if</span> (trans &amp;&amp; !trans.sampled) &#123;</span><br><span class="line">    <span class="keyword">return</span> original</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elasticAPMCallbackWrapper</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">elasticAPMCallbackWrapper</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prevTrans = ins.currentTransaction</span><br><span class="line">    ins.currentTransaction = trans</span><br><span class="line">    ins.bindingSpan = <span class="literal">null</span></span><br><span class="line">    ins.activeSpan = span</span><br><span class="line">    <span class="keyword">if</span> (trans) trans.sync = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (span) span.sync = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    ins.currentTransaction = prevTrans</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async hook 是 Node.js 8 以后出现的概念，为了兼容旧版本，Elastic APM 借助 <code>async-listener</code> 模块做了一些兼容，尽管 Elastic APM 官方不推荐使用低版本 Node.js 接入。</p><p>虽然 async hook 更进一步可以帮助优化异步调用栈，改善异步 Error 信息的可读性，但 APM 很难从底层判断哪些异步 CallSite 是用户想保留的，所以没有做这种处理。</p><h3 id="Span-Trace"><a href="#Span-Trace" class="headerlink" title="Span Trace"></a>Span Trace</h3><p>Span 用来记录 db 操作、http、websocket 远程调用等细致操作，Elastic APM 同时记录了调用栈。</p><p>我们知道，console.trace() 方法可以用来定位 trace 信息，它实际使用了 V8 Error 暴露的另一个方法 <code>Error.captureStackTrace(error, constructorOpt)</code>。</p><p><code>error</code> 是用来记录 trace 信息的必传对象，captureStackTrace 会将字符串附加到 error 对象的 stack 属性上。</p><p><code>constructorOpt</code> 是用来隐藏底层调用栈的可选函数，用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, MyError);</span><br><span class="line">  <span class="comment">// Any other initialization goes here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h4><p>上面提到的 V8 Error trace API，结合 TJ 的 <code>callsite</code> 更容易理解，功能是获取当前的 CallSite 集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> orig = <span class="built_in">Error</span>.prepareStackTrace;</span><br><span class="line">  <span class="built_in">Error</span>.prepareStackTrace = <span class="function"><span class="keyword">function</span>(<span class="params">_, stack</span>)</span>&#123; <span class="keyword">return</span> stack; &#125;;</span><br><span class="line">  <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>;</span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(err, <span class="built_in">arguments</span>.callee);</span><br><span class="line">  <span class="keyword">var</span> stack = err.stack;</span><br><span class="line">  <span class="built_in">Error</span>.prepareStackTrace = orig;</span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不得不说，和活跃的商业巨头产品相比，Elastic APM 目前的功能支持度存在不少差距。如果想在 APM 专业领域探索，绕不开对 New Relic 源码的学习。 XD</p><p>但 Elastic APM Node.js 依然是目前最值得关注的开源探针式监控方案，其 agent 基础功能支持度较好，代码结构也很简单，希望能被更多人使用，帮助它更快成长~</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/elastic/apm-agent-nodejs" target="_blank" rel="noopener">https://github.com/elastic/apm-agent-nodejs</a></li><li><a href="https://v8.dev/docs/stack-trace-api" target="_blank" rel="noopener">https://v8.dev/docs/stack-trace-api</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;根据上一篇《&lt;a href=&quot;https://claude-ray.github.io/2019/05/19/node-apm-product-research/&quot;&gt;Node.js APM 产品调研&lt;/a&gt;》的市场调研结果，笔者更青睐 Elastic APM 这个开源产品，故决定带来它的一篇专题介绍。&lt;/p&gt;
&lt;p&gt;尽管团队已经开始试用，但踩坑时间较短，与其编写测评，不如先带大家走进这个项目，剖析个别令人感兴趣的技术点。&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="APM" scheme="https://claude-ray.github.io/tags/APM/"/>
    
      <category term="Elastic-APM" scheme="https://claude-ray.github.io/tags/Elastic-APM/"/>
    
      <category term="V8" scheme="https://claude-ray.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>让 Node.js Server 优雅退出</title>
    <link href="https://claude-ray.github.io/2019/05/23/node-graceful-server/"/>
    <id>https://claude-ray.github.io/2019/05/23/node-graceful-server/</id>
    <published>2019-05-23T07:12:28.000Z</published>
    <updated>2019-08-08T15:52:43.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>服务进程登场时往往“蓄势而发”，犹抱琵琶半遮面，真正的服务端口跑起来之前做了太多准备工作，然而落幕工作常被人草草了之。</p><p>如何让进程自然结束，这本是 hello world 级的基础内容，却有很多项目忽视了这一步的必要性以及重要性。</p><p>目前使用 PM2 作为进程管理的项目仍占多数，有相关意识的朋友使用 <code>pm2 reload</code> 让进程“平滑”重启，但这就不需要额外的代码处理了吗？</p><p>举个例子，未捕获的异常导致服务强行退出时，是不是有可能进程尚未记录异常日志、请求执行到了一半、甚至中断了更复杂的业务工作？PM2 只能截住新的请求，旧的请求是否彻底执行完毕，仍需要业务自己判断。</p><p>下面我们先抛开 PM2 ，聊聊基本的进程退出需要哪些工作。首先我们从未捕获的异常说起。</p><a id="more"></a><h2 id="uncaughtException"><a href="#uncaughtException" class="headerlink" title="uncaughtException"></a>uncaughtException</h2><p>在进程退场前做好日志记录工作，算是基本需求之一。</p><blockquote><p>预先约定，本篇示例代码中出现的 <code>logger</code> 均为 log4js 或 console 等日志模块的伪代码。</p></blockquote><p>默认情况下，控制台打印 <code>Uncaught exception xxx</code> 之后直接退出。如果是用 log4js 记录日志到文件或推送远程日志库，不好意思，很可能发现记录中什么错误信息都没留下。</p><h3 id="server-close-是核心"><a href="#server-close-是核心" class="headerlink" title="server.close() 是核心"></a>server.close() 是核心</h3><p>优雅退出的核心方法是调用 <a href="https://nodejs.org/api/net.html#net_server_close_callback" target="_blank" rel="noopener">server.close([callback])</a>，用于停止 server 接受建立新的连接，并保持已经存在的连接。当所有的连接关闭同时 server 响应 ‘close’ 事件时，server 才会最终关闭，并调用回调函数（可选的）。另外, 如果服务器在未开启状态下执行 close，将会抛出 error 作为回调函数的唯一参数。</p><p>在 close 回调函数里可确保没有未结束的请求，也就能放心结束进程。网上随处可见的最基本的处理版本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">async</span> err =&gt; &#123;</span><br><span class="line">  logger.error(<span class="string">`Uncaught exception:`</span>, err)</span><br><span class="line">  server.close(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    logger.info(<span class="string">'Server is closed'</span>)</span><br><span class="line">    process.exit(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="确保-close-成功"><a href="#确保-close-成功" class="headerlink" title="确保 close 成功"></a>确保 close 成功</h3><p>然而这离我们的目标还有段距离，代码运行一段时间就会遇到问题，异常记录是有了，server 迟迟没有退出的迹象。因为有很多 http 请求是 keep-alive 的，只要这些连接释放不掉，server 就无法 close，同时会有源源不断的新请求进来。</p><p>这也是为什么有人采用 setTimeout 计时强制关闭超时的 server.close。然而 setTimeout 方式治标不治本，既然阻塞退出的根源是 keep-alive 没能立刻关闭，就通过 <a href="https://nodejs.org/api/http.html#http_server_keepalivetimeout" target="_blank" rel="noopener">server.keepAliveTimeout</a> (新增于v8.0.0) 缩短其持续的时间吧。</p><p>另外，我们为了把可能的错误都收集起来，server.close 的异常也放到在日志中去。</p><blockquote><p>事实上，Node.js 只会在这里抛出一种错误 <code>ERR_SERVER_NOT_RUNNING</code>，<a href="https://github.com/nodejs/node/blob/master/lib/net.js#L1517" target="_blank" rel="noopener">源码</a>为证，所以这里日志没太多必要，下一小节会加深这个想法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">async</span> err =&gt; &#123;</span><br><span class="line">  logger.fatal(<span class="string">`Uncaught exception:`</span>, err)</span><br><span class="line">  server.keepAliveTimeout = <span class="number">1</span></span><br><span class="line">  server.close(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">      logger.error(<span class="string">'Error while server is closing'</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">'Server is closed'</span>)</span><br><span class="line">    process.exit(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    logger.warn(<span class="string">'Server close timeout! Process exit 1'</span>)</span><br><span class="line">    process.exit(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">10000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码依然保留了 setTimeout 的退出方式，避免有时候真的出现特殊异常。</p><h3 id="close-其他连接"><a href="#close-其他连接" class="headerlink" title="close 其他连接"></a>close 其他连接</h3><p>接下来介绍一种会导致关闭失败的情况：该 server 被用来建立了 websocket 连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br></pre></td></tr></table></figure><p>如果不显示执行 socket server 的 close 方法，仍然被认为有连接未被释放。因此，不得不再加上 socket 的处理，当然你也可以考虑其他方式断开 socket 连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.server.close()</span><br></pre></td></tr></table></figure><p>需要提醒的是，像上面这样 http 和 websocket 共用端口，直接关闭 websocket 意味着将对同一个 server 调用两次 close 方法，可能导致 http 服务的 close 回调抛错，还记得该回调函数只会抛出的一种错误吗？Bingo! 也许 close 回调中的错误真的没有记录的必要了。</p><p>好吧，进程终于可以正常退出了，这就完了吗？当然没有！</p><p>如果程序中还保持着 mysql，redis 等等服务的连接，或者有异步的操作的话，继续等这些连接关闭、任务执行完毕吧。</p><h2 id="unhandledRejection"><a href="#unhandledRejection" class="headerlink" title="unhandledRejection"></a>unhandledRejection</h2><p>再提一下 unhandledRejection，尽管目前 Node.js 不会因此而主动退出进程，但将来会。</p><blockquote><p>In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code</p></blockquote><p>业务最好做一下适当把控，最起码，监听这个事件是有助于自定义的日志记录。之前的 uncaughtException 也同样适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="keyword">async</span> err =&gt; &#123;</span><br><span class="line">  logger.error(<span class="string">`Unhandle Promise rejection:`</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="SIGINT"><a href="#SIGINT" class="headerlink" title="SIGINT"></a>SIGINT</h2><p>说完了异常退出，别忘了正常退出，最常见的事件是 <code>SIGINT</code>，使用 PM2 停止或重启进程时就会触发。</p><p>但处理起来保持和 uncaughtException 一致就好了，除了这里的 exit code 应该是 0。</p><h2 id="PM2-Graceful-Shutdown"><a href="#PM2-Graceful-Shutdown" class="headerlink" title="PM2 Graceful Shutdown"></a>PM2 Graceful Shutdown</h2><p>有工具自然要好好利用，但 PM2 不止有 reload。</p><p>写到这里，笔者犯懒了，文档链接先放这，有时间再考虑搬运，请按需自取 XD</p><p><a href="https://pm2.io/doc/en/runtime/best-practices/graceful-shutdown/" target="_blank" rel="noopener">https://pm2.io/doc/en/runtime/best-practices/graceful-shutdown/</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上，进程退场要做的事情其实并不少，日志的记录方式依赖于实际技术栈，不太容易封装成通用的库，一般得结合自身框架定制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;服务进程登场时往往“蓄势而发”，犹抱琵琶半遮面，真正的服务端口跑起来之前做了太多准备工作，然而落幕工作常被人草草了之。&lt;/p&gt;
&lt;p&gt;如何让进程自然结束，这本是 hello world 级的基础内容，却有很多项目忽视了这一步的必要性以及重要性。&lt;/p&gt;
&lt;p&gt;目前使用 PM2 作为进程管理的项目仍占多数，有相关意识的朋友使用 &lt;code&gt;pm2 reload&lt;/code&gt; 让进程“平滑”重启，但这就不需要额外的代码处理了吗？&lt;/p&gt;
&lt;p&gt;举个例子，未捕获的异常导致服务强行退出时，是不是有可能进程尚未记录异常日志、请求执行到了一半、甚至中断了更复杂的业务工作？PM2 只能截住新的请求，旧的请求是否彻底执行完毕，仍需要业务自己判断。&lt;/p&gt;
&lt;p&gt;下面我们先抛开 PM2 ，聊聊基本的进程退出需要哪些工作。首先我们从未捕获的异常说起。&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="graceful-server" scheme="https://claude-ray.github.io/tags/graceful-server/"/>
    
      <category term="pm2" scheme="https://claude-ray.github.io/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>Node.js APM 产品调研</title>
    <link href="https://claude-ray.github.io/2019/05/19/node-apm-product-research/"/>
    <id>https://claude-ray.github.io/2019/05/19/node-apm-product-research/</id>
    <published>2019-05-19T13:52:35.000Z</published>
    <updated>2019-07-28T09:07:39.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://en.wikipedia.org/wiki/Application_performance_management" target="_blank" rel="noopener">Application Performance Management</a>（简称 APM）是监控服务的一套技术手段，致力于监控并管理程序的性能和可用性。</p><p>不妨思考一下，当有用户反映操作无响应，如何排查问题？惯例是先自己尝试重现，如果没重现，再换一个人试试，bla bla…</p><p>从用户击下按键开始，到服务呈现最终效果的过程中，有哪些因素会导致阻塞？</p><p>是否真的未响应？有没有可能是网络过慢导致？</p><p>丢包？用户网络质量还是机房故障？出现在机群哪一层？</p><p>代码BUG？自己的还是别人的？</p><p>能快速定位是哪一环节出了问题吗？</p><p>用户的请求从客户端 -&gt; CDN -&gt; 代理 -&gt; 中间层 -&gt; 服务1 -&gt; 服务2 -&gt; …</p><p>线上应用的性能表现是极为复杂的，运维的感知总是慢于业务，人工监控或草木皆兵、或亡羊补牢。因此需要一个合理的监控措施以便诊断服务质量，提高运维和业务的工作效率，间接服务于提升用户体验。</p><p>尽管上面的例子和请求链路相关，许多人就将 APM 和 <code>分布式链路跟踪系统</code> 混为一谈，其实并不恰当。 APM 当然可以承载 Tracing 工作，但除此之外还包含内存、CPU、RT、TPS、QPS等等监控职能，链路分析仅是其中一环罢了。为了更清晰地阐述，下面先简单介绍一下 APM 的基本定义。</p><h2 id="关于-APM"><a href="#关于-APM" class="headerlink" title="关于 APM"></a>关于 APM</h2><p>APM 是 <code>Gartner</code> 抽象出的一个管理模型，有如下定义。</p><p><img src="/image/node-apm-product-research/apm-coneptual-framework.jpg" alt="APM Coneptual Framework"></p><p>通俗的说法如下</p><ol><li>终端用户体验：反馈真实用户的体验，包括高峰时的服务、组件平均响应时间。</li><li>应用架构映射：能否分析真实请求链路。</li><li>应用事务分析：要求有序、完整地记录事务信息，能够定位两个操作是否为同一个用户，且信息具备唯一性。</li><li>深度应用诊断：用户反馈问题时，能精准定位问题点，通常需要做更底层的监控。同时又有着部署简单、副作用低的要求，这是 APM 应用的主要难点所在。</li><li>分析与报告：数据要实时且精准，大数据的存储与查询，目前已经不难应对。</li></ol><p>2016 年， Gartner 又将上述 5 个维度更新为 3 个新维度。</p><ul><li>数字体验监控 (DEM)：对应用户体验监控</li><li>应用发现、跟踪、诊断 (ADTD)：整合并了应用架构映射、事务分析、深度应用诊断</li><li>应用分析 (AA)：对应分析与报告</li></ul><p>除了 DEM ，基本概念和旧维度呈对应关系，为了方便理解，下面提一下 Gartner 对 DEM 的定义。</p><blockquote><p>an availability and performance monitoring discipline that supports the optimization of the operational experience and behavior of a digital agent, human or machine, as it interacts with enterprise applications and services. For the purposes of this evaluation, it includes real-user monitoring (RUM) and synthetic transaction monitoring (STM) for both web- and mobile-based end users.</p></blockquote><p>实质依然是通过用户的角度分析关键业务（RUM），通过测试消除潜在的错误和性能瓶颈（STM），以数字化增强监控分析能力。</p><h1 id="主流-APM-简介"><a href="#主流-APM-简介" class="headerlink" title="主流 APM 简介"></a>主流 APM 简介</h1><h2 id="商业软件"><a href="#商业软件" class="headerlink" title="商业软件"></a>商业软件</h2><h3 id="New-Relic"><a href="#New-Relic" class="headerlink" title="New Relic"></a>New Relic</h3><blockquote><p><a href="https://newrelic.com/nodejs" target="_blank" rel="noopener">https://newrelic.com/nodejs</a></p></blockquote><p>New Relic 是专研 APM 的代表性公司，并凭借其技术产品于 2014 年上市。抛开其他语言市场的激烈角逐，它在 Node.js APM 产业是真正的龙头。虽然监控服务需要付费，数据上传到云端才能使用，但其 SDK 源代码完全开放，可以清晰地看到它对各探针的实现，对接入方开发者十分友好，也因此成为各监控服务的模仿对象。</p><p>是付费用户的首选。</p><h3 id="AppDynamics"><a href="#AppDynamics" class="headerlink" title="AppDynamics"></a>AppDynamics</h3><blockquote><p><a href="https://www.appdynamics.com/nodejs" target="_blank" rel="noopener">https://www.appdynamics.com/nodejs</a></p></blockquote><p>AppDynamics 一直是 New Relic 的竞争对手，有意思的是，两家公司的创始人分别是来自同一家公司的首席架构师、CEO ，并在同一年创立。</p><p>AppDynamics 公司在 2016 年上市，它提供的服务也非常强大，但和 New Relic 的市场定位不同，New Relic 初期战略主要针对小型创业公司，而 AppDynamics 则专攻企业。且 AppDynamics 可以部署在公司内部数据中心，而不只是作为云端服务。</p><p>其 SDK 代码不完全开放，使用了经过编译的 jar 包和二进制文件。</p><h3 id="Dynatrace"><a href="#Dynatrace" class="headerlink" title="Dynatrace"></a>Dynatrace</h3><blockquote><p><a href="https://www.dynatrace.com/technologies/nodejs-monitoring/" target="_blank" rel="noopener">https://www.dynatrace.com/technologies/nodejs-monitoring/</a></p></blockquote><p>Dynatrace 和 New Relic、AppDynamics 并称为 APM 产业三大领军者，但在 Node.js 的市场占有率和热度很低，不开放源代码，无法深度化定制，难以认可它已经是成熟的产品。</p><h3 id="Atatus"><a href="#Atatus" class="headerlink" title="Atatus"></a>Atatus</h3><blockquote><p><a href="https://www.atatus.com/for/nodejs" target="_blank" rel="noopener">https://www.atatus.com/for/nodejs</a></p></blockquote><p>支持功能一般，只能算二线产品，况且其 SDK 做了代码混淆。</p><h3 id="听云"><a href="#听云" class="headerlink" title="听云"></a>听云</h3><blockquote><p><a href="https://doc.tingyun.com/server/html/node/install.html" target="_blank" rel="noopener">https://doc.tingyun.com/server/html/node/install.html</a></p></blockquote><p>国内团队，可以限量免费试用。估计很多人体验过，其很多功能（代码）借鉴自 New Relic，试用体验相仿，好在针对国内市场做了一些本地化，不过多介绍。</p><p>有 New Relic 做“后盾”，服务不会差到哪去，且提供免费版，小型项目不妨一用。</p><h3 id="OneAPM"><a href="#OneAPM" class="headerlink" title="OneAPM"></a>OneAPM</h3><blockquote><p><a href="https://www.oneapm.com/ai/nodejs.html" target="_blank" rel="noopener">https://www.oneapm.com/ai/nodejs.html</a></p></blockquote><p>类似听云，但给人的感觉是实力逊于听云，SDK 几乎照搬 New Relic，口碑毁于肆意打广告，不太讨喜。</p><h2 id="开源免费方案"><a href="#开源免费方案" class="headerlink" title="开源免费方案"></a>开源免费方案</h2><h3 id="Alinode"><a href="#Alinode" class="headerlink" title="Alinode"></a>Alinode</h3><p>由于这个方案存在较多争议，因此额外给了一些篇幅补充介绍。</p><h4 id="开发者介绍"><a href="#开发者介绍" class="headerlink" title="开发者介绍"></a>开发者介绍</h4><p>hyj1991 解释过 Alinode 对 Node Runtime 增加了哪些改动：</p><ul><li>增加了一些 V8 没有对外暴露的接口，比如 GC Trace 来动态输出 GC 日志</li><li>埋了一些点以性能损耗更低的方式采集进程级别的 CPU 和 Memory 数据</li><li>增加了动态开启 CPU / Memory / GC 状态采集的开关</li></ul><p>而对于负责开发者业务相关的 API 和功能逻辑，并无任何改动，这也是为什么 AliNode 和官方的 Runtime 可以无缝对切的原因。</p><p>至于安全问题，主要是担心会采集业务数据上报，但是实际上 AliNode 内核的上述改动，都不会直接向云端发送任何数据，而都是以本地 Log 的方式写入大家配置的 NODE_LOG_DIR 目录下，日志文件以 <code>node-日志.log</code> 的形式命名，不放心的话可以查看此文件内容。</p><p>实际上大家在控制台看到的数据，最后不管使用的是 egg-alinode 还是 agenthub 均是通过 agentx 这个库采集上报的，这个库首先它是开源的，大家可以自行阅读相关采集代码观察是否上报了敏感数据。最后实在对安全问题存在疑虑的，可以通过 Wireshark 等抓包工具，来抓取 AliNode 输出的日志和 Agentx 上报的数据内容，看看是否上报的数据中存在大家非常担心的敏感数据。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>严格来说 Alinode 不能算作开源方案，但其实它只有后台和启动代码是闭源的，尤其对小团队而言接入成本低，是非常值得考虑的接入方案。</p><p>而且由于日志收集进程开源，除了没有开源的收集 v8 内部性能的功能，其他信息都可以通过接入自己的日志系统或后台进行分析。</p><p>但从企业角度出发，还是完全由自己掌控的方案更放心。</p><h3 id="Easy-Monitor"><a href="#Easy-Monitor" class="headerlink" title="Easy Monitor"></a>Easy Monitor</h3><blockquote><p><a href="https://github.com/hyj1991/easy-monitor" target="_blank" rel="noopener">https://github.com/hyj1991/easy-monitor</a></p></blockquote><p>终于提到了一个完全开源的方案了，它的开发者同样是 hyj1991，可惜功能实在简单，仅提供性能监控，维护度较低。</p><p>目前最大的价值是作为学习项目，而不是投入生产环境。</p><h3 id="Pandora-js"><a href="#Pandora-js" class="headerlink" title="Pandora.js"></a>Pandora.js</h3><blockquote><p><a href="https://midwayjs.org/pandora/zh-cn/" target="_blank" rel="noopener">https://midwayjs.org/pandora/zh-cn/</a></p></blockquote><p>来自阿里 midwayjs 团队，是类似于 PM2 的一个启动进程，因此最大优点是无代码侵入。</p><p>目前功能尚不完备，支持star、restart、stop，调试时为了查看 debugger 记录，可加上 <code>--inspect</code> 参数，暂不支持平滑 reload。</p><p>Dashboard 只能单机部署单机监控，无法集群监控，目前 midway 的使用方案是结合 ElasticSearch。</p><p>据说已经在阿里内部落地，现在正重构 2.0 版本，等待此项目成熟可考虑使用。很希望能替代臃肿的 PM2。</p><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><blockquote><p><a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a></p></blockquote><p>在国外非常流行，相比业务方，更多地被运维熟知，是一种监控和报警的开源生态。SDK 和界面有多重组合方式，Node.js 一般结合 <code>prom-client</code>(非官方 npm 包) + <code>Granfana</code> 使用。</p><p>只做性能采集，不支持 trace 跟踪。目前已知缺陷是内存占用较高和日志量巨大，数据可以选择本地存储或远程接口存储。</p><p>开源的一大选择方案，落地可能对运维团队要求较高。</p><h3 id="Elastic-APM"><a href="#Elastic-APM" class="headerlink" title="Elastic APM"></a>Elastic APM</h3><blockquote><p><a href="https://www.elastic.co/solutions/apm" target="_blank" rel="noopener">https://www.elastic.co/solutions/apm</a></p></blockquote><ul><li>APM: <a href="https://www.elastic.co/guide/en/apm/get-started/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/apm/get-started/current/index.html</a></li><li>Node Client: <a href="https://www.elastic.co/guide/en/apm/agent/nodejs/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/apm/agent/nodejs/current/index.html</a></li><li>Kibana APM: <a href="https://www.elastic.co/guide/en/kibana/current/xpack-apm.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/xpack-apm.html</a></li></ul><p>这是 Elastic 体系下的完全开源的 APM 解决方案，也提供商业付费服务。文档一如既往地丰富，上面列举了其中三个入口。</p><p>日志采集进程为 golang 编写的 apm-server，最终将数据存储到 ElasticSearch，Kibana 内置了 APM 基础看板。</p><p>官方提供 API 来支持深度定制，golang 降低了二次开发的成本，更不用担心 Kibana 看板功能不够用。总之，是相当全面的解决方案，之后会单独开一篇文章介绍。</p><h1 id="选型概述"><a href="#选型概述" class="headerlink" title="选型概述"></a>选型概述</h1><h2 id="要点维度"><a href="#要点维度" class="headerlink" title="要点维度"></a>要点维度</h2><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>进程级的 CPU、内存指标监控，这是 APM 最基本功能，普遍支持。</p><p>更高级的是 V8 监控，heap 信息，做出 profile 等诊断。但实际上 Node 最新版本已经暴露出 V8 heap 的接口，profile 也完全可以需要时主动创建，重要性反而不是特别高。</p><h3 id="代码级监控"><a href="#代码级监控" class="headerlink" title="代码级监控"></a>代码级监控</h3><p>监控到代码细节，不是简单的错误定位，而是分析哪段代码有内存泄露、提供 SQL 慢查询日志等更实用的功能。</p><h3 id="事务监控"><a href="#事务监控" class="headerlink" title="事务监控"></a>事务监控</h3><p>分析业务流程、请求响应时间等。</p><h3 id="框架支持"><a href="#框架支持" class="headerlink" title="框架支持"></a>框架支持</h3><p>要实现对 npm 依赖的监控，例如路由的追踪，是需要明确定制化到特定包的，例如 express、koa、bluebird、sequelize 等。</p><p>这里只考虑了主流的 Express 和 Koa HTTP 框架，有特殊需要的请进一步到官方了解。</p><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><p>一个请求从创建到响应的链路分析。</p><h3 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h3><p>能否识别集群的部署状况。</p><h3 id="代码侵入"><a href="#代码侵入" class="headerlink" title="代码侵入"></a>代码侵入</h3><p>对代码侵入程度越低，接入越方便，避免对业务造成影响。</p><p>虽然移除一个模块时代码的改动大小是评判侵入性高低的一般标准，并且下面也将遵循此标准来进行评价。但必须留意，除了引入 SDK 的方式，如何使用 async hook、如何对第三方库做 Patch(类似 Java 动态字节码探针)，再低的侵入都可能埋下隐患。</p><h3 id="社区活跃度"><a href="#社区活跃度" class="headerlink" title="社区活跃度"></a>社区活跃度</h3><p>社区活力是很重要的软指标，但我们拿不到服务商未公开的统计数据，只能以 npm 最近的下载量作为参考。</p><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><p>只有开源和小部分商业方案支持数据内网存储，这样才能最大地保障数据安全。</p><p>但如果项目本身不设置重要数据，这个问题就得结合自身情况重新考量。</p><h3 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h3><p>如果选择自行存储数据，就需要考虑部署数据库等依赖的成本。</p><p>方案能否落地，取决于项目相关的数据团队、运维团队，此维度也请各位自行评估。</p><h2 id="关于-Node-js"><a href="#关于-Node-js" class="headerlink" title="关于 Node.js"></a>关于 Node.js</h2><p>Node.js 在服务端尤其是中间层表现不俗，但如果经验不足的情况下将 Node 落地，没有任何监控，承担的风险太大。</p><p>小团队的发布流程和运维支撑通常较弱，难以避免线上故障，这一阶段，快速响应和处理才能降低损失。</p><p>考虑到 APM 的接入成本，有必要分清接入功能的优先级。</p><p>在虚拟化、容器化的现在，大部分性能指标的采集工作都可以在业务之外进行，因此性能采集只要能做到进程级的监控即可。</p><p>分布式全链路追踪，不是只在 Node 一端接入就有效果的，必然要结合运维和后端技术栈，选择使用 Zipkin 等更流行的 opentracing 开源方案。</p><p>如果上面的观点你还算认可，那么我们选型上应该更关注 APM 服务对代码级监控的支持力度、侵入程度、社区活跃度和接入成本。</p><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>综上，APM 的选型参考如下</p><table><thead><tr><th>名称</th><th>Express</th><th>Koa</th><th>性能</th><th>代码级</th><th>事务</th><th>链路</th><th>分布式</th><th>侵入</th><th>实现方式</th><th>npm周下载量(+)</th></tr></thead><tbody><tr><td>newrelic</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>30.1k</td></tr><tr><td>appdynamics</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>9.5k</td></tr><tr><td>dynatrace</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>0.1k</td></tr><tr><td>atatus</td><td>✓</td><td>✓</td><td>✓</td><td>×</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>0.6k</td></tr><tr><td>tingyun</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>0.3k</td></tr><tr><td>one apm</td><td>✓</td><td>×</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>0.1k</td></tr><tr><td>alinode</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>无</td><td>run time</td><td>-</td></tr><tr><td>easy monitor</td><td>✓</td><td>✓</td><td>✓</td><td>×</td><td>×</td><td>×</td><td>✓</td><td>低</td><td>探针</td><td>0.1k</td></tr><tr><td>pandora</td><td>✓</td><td>✓</td><td>✓</td><td>×</td><td>✓</td><td>✓</td><td>×</td><td>极低</td><td>进程启动器</td><td>0.2k</td></tr><tr><td>Prometheus</td><td>✓</td><td>✓</td><td>✓</td><td>×</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>20.1k</td></tr><tr><td>elastic apm</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>低</td><td>探针</td><td>24.6k</td></tr></tbody></table><h2 id="自研"><a href="#自研" class="headerlink" title="自研"></a>自研</h2><p>普遍场景下，在日志层面做好业务监控即可，参考下面的流程，只要不涉及 Stack、SQL 等代码级监控，就能以较低开发成本、低侵入式地实现核心业务监控。</p><ol><li>基于 Node.js 自带的 API 完成探针，并在关键业务做好相关埋点，将数据(日志)打点到 Kafka。</li><li>另起服务进程，专门消费 Kafka 的监控队列，推送到 ElasticSearch 服务中。</li><li>通过 Kibana 的看板完成一系列定制化的数据分析。</li></ol><p>如果是更复杂的需求，则不建议造轮子，而是基于开源方案二次开发。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>无论如何，我更倾向选用开源方案，但目前开原方案的代码级监控都是短板，那么这也成为自研和深度定制的困难所在。</p><p>末尾重申，APM 属于运维技术的范畴，业务方自己搭建时，最好结合自身需求定制，当心过犹不及。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/Application_performance_management" target="_blank" rel="noopener">维基百科-Application performance management</a></li><li><a href="http://network.51cto.com/art/201503/469273.htm" target="_blank" rel="noopener">什么是真正的APM？</a></li><li><a href="https://www.zhihu.com/question/315261661" target="_blank" rel="noopener">关于Nodejs的性能监控思考？</a></li></ul>]]></content>
    
    <summary type="html">
    
      近期调研了当下 Node.js 主流的 APM 产品，为期不到一周，本文以介绍基本状况为主，引申对 APM 中间件选型乃至自研的一些思考。APM 虽和业务关系紧密，但实属于运维管理范畴，笔者从业务的角度思考，易受限于使用场景，请路过的读者及时指教问题。
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="APM" scheme="https://claude-ray.github.io/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 分页查询优化思路</title>
    <link href="https://claude-ray.github.io/2019/03/11/mysql-pagination/"/>
    <id>https://claude-ray.github.io/2019/03/11/mysql-pagination/</id>
    <published>2019-03-11T14:11:05.000Z</published>
    <updated>2019-03-14T14:14:55.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>突破查询瓶颈的方法有很多，但这里先不谈分库分表之流，当头问题就一个：单数据表分页查询过慢怎么办？</p><p>其实讲分页优化的博客真不少，但很多博主只顾分享点子忽略了细节，还有很多值得补充的地方。笔者回顾了曾经在千万级 BBS 项目的优化经历，尽可能结合实际地聊聊个人对分页查询的见解。也希望读者在亲身操作中验证，任何优化脱离了实际场景都是纸上谈兵。</p><a id="more"></a><h2 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h2><p>首先介绍最常见的数据分页方式，即传统分页和流式分页。</p><h3 id="传统分页"><a href="#传统分页" class="headerlink" title="传统分页"></a>传统分页</h3><p><img src="/image/mysql-pagination/01.png" alt="贴吧PC分页"></p><p>传统分页的基本逻辑是每页展示固定的条目数、通过页码分页和翻页，包含要素如下：</p><ul><li>首页：按序查询出一页长度的数据，作为顶部数据，无须处理偏移量。</li><li>下一页：除了末页都有下一页。通过页数能确定当前数据的偏移量，和数据总数比较可以判断是否还有下一页。偏移量可用于获取下一页的信息。</li><li>上一页：除了首页都有上一页。其余同上。</li><li>跳转：同上，偏移量来判断是否支持跳转到该页。</li><li>总页数：只要记住数据总量，除一下就能得到页数。结合跳转功能使用。</li><li>末页：许多系统会支持跳转到最后一页，根据总页数或总量即可实现。</li></ul><p>翻页和跳转功能为查询效率带来了极大挑战，一方面带着偏移量的 MySQL 查询效率不高，另一方面功能上也存在缺陷，例如浏览当前页面的过程中发生数据新增或删除，页码编号已经重置，此时翻页后会出现数据“重复”或“缺失”的问题。</p><h3 id="流式分页"><a href="#流式分页" class="headerlink" title="流式分页"></a>流式分页</h3><p><img src="/image/mysql-pagination/02.png" alt="贴吧Mobile分页"></p><p>流式分页简单得多，即只能一页一页向下加载，偏移量不固定，不提供跳转。常见于移动端，它不仅解决了传统分页的功能缺陷，间接对查询性能有所提升。</p><p>因此分页设计时产品层的优化必不可少，尽量选择流式分页。</p><p>不过 BBS 类型的 Web 项目为了方便用户，奉行 PC 端使用传统分页，移动端使用流式分页的设计理念。如果对这种设计没概念，可以左转百度贴吧。这要求我们必须直面传统分页带来的性能挑战。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>索引优化的套路属于另一个范畴了，应当视具体引擎、数据分布、锁等信息来权衡处理。在这里主要强调一点，使用覆盖索引避免回表查询。因为 InnoDB 查询偏移量 offset 的过程是先查出 offset + limit 条数据，再抛弃前 offset 条数据，偏移量过大时查询效率将低到令人发指。</p><p>因此，必须禁止分页查询时使用<code>select *</code>，充分利用索引中存储的信息，才能避免大量的回表取值操作。</p><p>不必追求一次查询得到完整结果，如果索引不包含待查询的字段，只查出主键 id 亦可，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>拿到 id 的集合后，大部分博客的处理都将这一步作为子查询，使用 <code>in</code>、<code>join</code> 或<code>比较符</code>继续查出数据详情。</p><p>但我们应当慎用子查询，尽量将查 id 和查数据分开进行，这便于之后的<a href="#缓存优化">缓存优化</a>。</p><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>要提升查询效率，最终实现的效果必然是所有查询都命中缓存。</p><p>为了避免频繁使用 count()，数据总数应当放在缓存中，但同时也破坏了一致性。如果你十分看重总数目的准确性，注意加上定时任务或缓存淘汰等同步机制。</p><p>对分页数据的缓存，不要直接以页数存储整页数据，否则任何数据的增减都将使所有页缓存作废。</p><p>区分开哪些内容是频繁更新的、哪些是相对稳定的。相对一页应该存哪几条数据，具体数据内容的更新频率低很多，因此较好的做法是使用 hash 缓存每一页的 id 列表，使用 string (whatever) 缓存每一条数据。</p><p>拿到 id 列表之后，无需回表，可直接到 redis 获取对应信息。</p><blockquote><p>另外针对新手提醒一点，不要 for 循环查询 redis，多次请求 redis 的网络开销得不偿失。可以使用 pipeline 将一串请求包起来，且整个管道操作是非原子的，不会阻塞 redis。至于另一类原生批量操作是原子的，如 mget，会阻塞其他 redis 操作。</p></blockquote><h2 id="末页优化"><a href="#末页优化" class="headerlink" title="末页优化"></a>末页优化</h2><p>尽管理论上 B+Tree 近乎二分查找，但对于有较大复杂度的数据表，不可能为每种查询都建立最优索引。优化到一定程度后索引数量和效率的折中就是拆东墙补西墙了，最终很可能威胁到某个 sql 的大偏移量查询。而末页查询恰好是 offset 最大的时候。</p><p>喜欢翻旧账的可能人不多，但看到“最后一页”按钮时，恐怕没几个人能忍住不点一下。这个按钮的受欢迎程度就算不如“第二页”，也肯定超过“四五六七八…页”。</p><p>不少的点击量加大了数据的查询压力，若是查询过慢导致内容半天加载不出来，更会诱发用户主动刷新发起更多请求。想想就够恐怖的。</p><p>笔者在使用才 500 万的数据做复杂查询时，offset 效率就又一次成为瓶颈。但查询第一页的效率总是非常快，那只要保证末页的速度达到和首页一样快，也就能达成优化目标。具体做法看下面的 sql ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>反向排序</code> 实现了末页等同于首页查询效率的效果。截止到 5.7 版本，MySQL 并没有在索引上区分 asc 和 desc，因此不需要新建索引，即可享用另一面的极速查询！</p><p>而且不仅仅是末页，实际上只要判断出偏移量超过总数目的一半，就可以进行反向 order 了。</p><p>注意此时得到一页数据的顺序也是反过来的，别忘了对该列表做个反转。除此之外，这种查询会导致最后一页永远是“排满”的，如有必要，可借助总数量修正最后一页应显示的条数，这样末页看起来和优化前一个样儿了。</p><p>也许是需要这么处理的场景比较少，最近只在这篇<a href="http://seanlook.com/2018/03/21/mysql-pagination-no-offset/" target="_blank" rel="noopener">文章</a>看到了相同的做法，该作者对优化细节的讲解更多，推荐一下。</p><h2 id="no-offset"><a href="#no-offset" class="headerlink" title="no offset"></a>no offset</h2><p>有 offset 的地方就有坑，干脆不要用了！服务端缓存好每一页的最小 id 确实问题不大，用 <code>&gt;</code>、<code>&lt;</code> 的效率比 offset 高多了。可惜按时间排序的数据 id 不一定是递增的，增删过后的更新难度较大。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>搜索引擎不一定能优化分页效率，例如 Elasticsearch 要通过集群各个节点的搜集才能查到偏移量之后的数据……</p><p>最后，任何不严谨的地方恳请斧正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;突破查询瓶颈的方法有很多，但这里先不谈分库分表之流，当头问题就一个：单数据表分页查询过慢怎么办？&lt;/p&gt;
&lt;p&gt;其实讲分页优化的博客真不少，但很多博主只顾分享点子忽略了细节，还有很多值得补充的地方。笔者回顾了曾经在千万级 BBS 项目的优化经历，尽可能结合实际地聊聊个人对分页查询的见解。也希望读者在亲身操作中验证，任何优化脱离了实际场景都是纸上谈兵。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://claude-ray.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://claude-ray.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>当 bind_ip:127.0.0.1 遇上 Debian 的默认 host</title>
    <link href="https://claude-ray.github.io/2019/02/21/bindip-debian-hostname/"/>
    <id>https://claude-ray.github.io/2019/02/21/bindip-debian-hostname/</id>
    <published>2019-02-21T13:35:43.000Z</published>
    <updated>2019-03-03T03:50:00.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>部署 RabbitMQ、MongoDB 或其他服务的单节点，有时会将 bind_ip 之类的设置写作 127.0.0.1。然而在 Debian 系统这么操作可能就给自己挖了“坑”，不管你有没有遇到过 <code>host</code> 相关奇怪的部署问题，来看作者的一波填坑历程吧~</p><h3 id="Debian-的-默认-hostname-配置"><a href="#Debian-的-默认-hostname-配置" class="headerlink" title="Debian 的 默认 hostname 配置"></a>Debian 的 默认 hostname 配置</h3><p>在 Debian 系的 Linux 发行版中，<code>/etc/hosts</code> 中前两行默认配置如下，其中 <code>myhostname</code> 即 <code>/etc/hostname</code> 指定的本机名称，可通过 <code>hostname</code> 指令查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.1.1 myhostname</span><br></pre></td></tr></table></figure><p>第二行配置将本机 host 指向了 <code>127.0.1.1</code>，这又能对软件的安装造成什么影响呢？请看下面的例子。</p><a id="more"></a><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><h3 id="MongoDB-举例"><a href="#MongoDB-举例" class="headerlink" title="MongoDB 举例"></a>MongoDB 举例</h3><p>我需要初始化一个 MongoDB 的单实例 Replset，并设置了 bindIP 为 127.0.0.1。这时调用 <code>rs.initiate()</code>，便会得到下列错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"ok"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">"errmsg"</span> : <span class="string">"No host described in new configuration 1 for replica set rs0 maps to this node"</span>,</span><br><span class="line">  <span class="string">"code"</span> : <span class="number">93</span>,</span><br><span class="line">  <span class="string">"codeName"</span> : <span class="string">"InvalidReplicaSetConfig"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面初始化 MongoDB 遇到的问题，其中一个解决方案是明确传递参数给 initiate 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(&#123;<span class="attr">_id</span>:<span class="string">"yourReplSetName"</span>, <span class="attr">members</span>: [&#123;<span class="string">"_id"</span>:<span class="number">1</span>, <span class="string">"host"</span>:<span class="string">"yourHost:yourPort"</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>参见 <a href="https://stackoverflow.com/a/30850962" target="_blank" rel="noopener">https://stackoverflow.com/a/30850962</a></p></blockquote><p>而生效原因不难解释，由于在初始化过程未指定 <code>host</code> ， MongoDB 默认读取了本机的 <code>hostname</code> 作为 <code>yourHost</code> 参数值。但本机的 hostname 指向 ip 是 127.0.1.1，因此整个 <code>host</code> 参数实际变为 <code>127.0.1.1:27017</code>。而 bindIP 仅绑定了 127.0.0.1，我们并没有 127.0.1.1:27017 这个服务，通过 <code>netstat</code> 也可以证实。</p><p>这也解释了另一个解决方法：修改 <code>/etc/hosts</code> 文件中本机 hostname 对应的 ip 为 127.0.0.1。</p><blockquote><p>参见 <a href="https://stackoverflow.com/a/29055110" target="_blank" rel="noopener">https://stackoverflow.com/a/29055110</a></p></blockquote><p>解决方案可能还有很多，比如可以在 bindIp 中加上 127.0.1.1…</p><h3 id="RabbitMQ-举例"><a href="#RabbitMQ-举例" class="headerlink" title="RabbitMQ 举例"></a>RabbitMQ 举例</h3><p>同上，RabbitMQ 的部署也存在相似问题。因为 RabbitMQ 默认 nodename 是 rabbit@<code>hostname</code>。</p><p>在这个 <a href="https://github.com/zulip/zulip/issues/194" target="_blank" rel="noopener">issue</a> 中也看到 zulip 维护者 timabbott 的描述：</p><blockquote><p>We’re working on migrating to a system where we change the default rabbitmq<br>nodename from rabbit@<code>hostname</code> to <code>zulip@localhost</code>, for new installs,<br>which I think would eliminate this problem, since <code>localhost</code> should always<br>resolve to 127.0.0.1.</p></blockquote><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>既然是普遍的问题，改 hostname 对应的 host 似乎成了最便捷的解决办法。既然如此，Debian 的默认 hostname 不写成 127.0.0.1 ？</p><p>这个 host 的主要作用是形成网络环路，并且 127.0.0.1 到 127.255.255.254 都是回环地址，选任一个 ip 都可以。至于为何选择 127.0.1.1，其实源于一个 bug，有兴趣可以从 debian 的 ref 追溯：<a href="https://www.debian.org/doc/manuals/debian-reference/ch05.en.html#_the_hostname_resolution" target="_blank" rel="noopener">https://www.debian.org/doc/manuals/debian-reference/ch05.en.html#_the_hostname_resolution</a></p><h2 id="FQDN"><a href="#FQDN" class="headerlink" title="FQDN"></a>FQDN</h2><p>改了这个 host 配置会导致其他异常吗？要解答这个疑问，需要先了解 FQDN。</p><p>引用<a href="https://onebitbug.me/2014/06/25/settings-fqdn-in-linux/" target="_blank" rel="noopener">《Linux下配置FQDN》</a>的描述。</p><blockquote><p>通常 hostname 在某个特定的范围内应该是唯一的，以免产生冲突，这个特定的范围通常用域（dnsdomain）表示。 而 fqdn（full qulified domain name）则应该在一个更大的范围内（比如全球）唯一， 通常 fqdn 是${hostname}.${dnsdomain}。 </p></blockquote><p>一旦修改了hostname到127.0.0.1，python 的 getfqdn() 将返回 <code>localhost</code> 而不是 <code>myhostname.dnsdomain</code>。结论：“这是为了最大程度的兼容各种工具的的getfqdn()实现”。</p><p>但如果你的项目不涉及相关内容，可以放心改动 /etc/hosts。顺便贴一个可以修改主机名对应的host为127.0.0.1”的脚本，可以加到服务的部署脚本中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/127.0.1.1\s<span class="variable">$(hostname)</span>/127.0.0.1 <span class="variable">$(hostname)</span>/"</span> /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然是个不起眼的问题，姑且串起来看还是有点意思的，<del>就这样又水了一篇博客</del>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;部署 RabbitMQ、MongoDB 或其他服务的单节点，有时会将 bind_ip 之类的设置写作 127.0.0.1。然而在 Debian 系统这么操作可能就给自己挖了“坑”，不管你有没有遇到过 &lt;code&gt;host&lt;/code&gt; 相关奇怪的部署问题，来看作者的一波填坑历程吧~&lt;/p&gt;
&lt;h3 id=&quot;Debian-的-默认-hostname-配置&quot;&gt;&lt;a href=&quot;#Debian-的-默认-hostname-配置&quot; class=&quot;headerlink&quot; title=&quot;Debian 的 默认 hostname 配置&quot;&gt;&lt;/a&gt;Debian 的 默认 hostname 配置&lt;/h3&gt;&lt;p&gt;在 Debian 系的 Linux 发行版中，&lt;code&gt;/etc/hosts&lt;/code&gt; 中前两行默认配置如下，其中 &lt;code&gt;myhostname&lt;/code&gt; 即 &lt;code&gt;/etc/hostname&lt;/code&gt; 指定的本机名称，可通过 &lt;code&gt;hostname&lt;/code&gt; 指令查看。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1 localhost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.1.1 myhostname&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;第二行配置将本机 host 指向了 &lt;code&gt;127.0.1.1&lt;/code&gt;，这又能对软件的安装造成什么影响呢？请看下面的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="Debian" scheme="https://claude-ray.github.io/tags/Debian/"/>
    
      <category term="hostname" scheme="https://claude-ray.github.io/tags/hostname/"/>
    
      <category term="fqdn" scheme="https://claude-ray.github.io/tags/fqdn/"/>
    
  </entry>
  
  <entry>
    <title>如何避免svn合并冲突</title>
    <link href="https://claude-ray.github.io/2019/01/29/ways-to-avoid-svn-conflict/"/>
    <id>https://claude-ray.github.io/2019/01/29/ways-to-avoid-svn-conflict/</id>
    <published>2019-01-29T14:13:36.000Z</published>
    <updated>2019-01-29T15:55:00.076Z</updated>
    
    <content type="html"><![CDATA[<p>svn 给笔者的一大印象就是非常容易产生冲突，特别是项目加入新人后，由于初期没有强硬地制定规范，导致后期合并代码时灾难连天。决定在此分享这些“亡羊补牢”的规则，也算是避免 svn 产生合并冲突的一点经验。</p><a id="more"></a><h2 id="一个简单的分支管理策略"><a href="#一个简单的分支管理策略" class="headerlink" title="一个简单的分支管理策略"></a>一个简单的分支管理策略</h2><p>正式分享 tips 前，先交代一下目前在用的 svn 管理策略，因为本文避免合并冲突的一些要点就是建立在此策略之上的。</p><p>类似于 git 的轻度规则，主要分为 dev、master、release 三种分支。</p><p>以 master 为核心，保存完整代码。release 则允许剔除未编译前端 js、测试用例、项目文档等运行环境不需要的文件，减轻发布体积。功能开发在各 dev 进行。因此 master 和 release 只需要处理代码合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发布分支        主干       开发分支</span><br><span class="line"></span><br><span class="line">release1 &lt;-            &lt;- dev</span><br><span class="line">release2 &lt;-   master   &lt;- feature</span><br><span class="line">...      &lt;-            &lt;- ...</span><br></pre></td></tr></table></figure><h2 id="如何避免冲突"><a href="#如何避免冲突" class="headerlink" title="如何避免冲突"></a>如何避免冲突</h2><h3 id="1-编辑器装好-svn-相关插件。"><a href="#1-编辑器装好-svn-相关插件。" class="headerlink" title="1. 编辑器装好 svn 相关插件。"></a>1. 编辑器装好 svn 相关插件。</h3><p>不同于“装机必备”的 git ，很多编辑器没有自带 svn 的管理插件，需要用户自己安装。</p><p>尤其重要的功能是可以实时对比 diff，本地和远程仓库的差异一览无遗，不要再疑惑为什么本地顺畅线上崩盘了。</p><p>windows 开发环境可能需要配置 svn 环境变量，但不要偷懒，这点工作一劳永逸。</p><h3 id="2-细化提交。"><a href="#2-细化提交。" class="headerlink" title="2. 细化提交。"></a>2. 细化提交。</h3><p>当合并时，假如发现同一个提交下存在还未达到上线状态的变更，这种情况如果忽略合并某些代码，会导致该开发分支和 master 分支不再一致，为后继的开发者挖坑。</p><h3 id="3-开发分支也要规范-commit-log。"><a href="#3-开发分支也要规范-commit-log。" class="headerlink" title="3. 开发分支也要规范 commit log。"></a>3. 开发分支也要规范 commit log。</h3><p>尽管开发分支可能在功能完成后就被删除，依然要有意识地为各个 commit 打上前缀、标签。</p><p>假设某开发分支是多人协作，若 commit log 有合适的标签，可以增加合并时的检索效率，避免遗漏部分久远的提交。当然，除非业务关联性较大，放在一个分支方便做同时修改，最好还是分模块、分特性单独建开发分支。</p><h3 id="4-所有的合并操作，采取针对版本号的更改。"><a href="#4-所有的合并操作，采取针对版本号的更改。" class="headerlink" title="4. 所有的合并操作，采取针对版本号的更改。"></a>4. 所有的合并操作，采取针对版本号的更改。</h3><p>其实主要面向需要长期维护的开发分支，直接合并目录树会携带大量不稳定变更。</p><h3 id="5-对完整的分支执行合并。"><a href="#5-对完整的分支执行合并。" class="headerlink" title="5. 对完整的分支执行合并。"></a>5. 对完整的分支执行合并。</h3><p>对整个分支目录执行合并，而不是对单个文件、单个子目录做合并，否则结合第 2 点，这极容易埋下隐患。</p><h3 id="6-牢记发布分支-release-是-master-的快照。"><a href="#6-牢记发布分支-release-是-master-的快照。" class="headerlink" title="6. 牢记发布分支 release 是 master 的快照。"></a>6. 牢记发布分支 release 是 master 的快照。</h3><p>禁止跨过 master 在 release 直接提交代码。更危险的是在 release 提交的代码和 master 不一致，好在上次遇到这么做的被我及时制止了。XD</p><p>进一步要求，不要在 master 直接提交解决冲突以外的代码。</p><h3 id="7-定期把-master-的所有更改合并回开发分支。"><a href="#7-定期把-master-的所有更改合并回开发分支。" class="headerlink" title="7. 定期把 master 的所有更改合并回开发分支。"></a>7. 定期把 master 的所有更改合并回开发分支。</h3><p>尤其是涉及工具类、公共模块的更改。当开发分支维护不下去时，以 master 为基准重建开发分支。</p><h3 id="8-遇到-GUI-解决不了的冲突，命令行参数了解一下。"><a href="#8-遇到-GUI-解决不了的冲突，命令行参数了解一下。" class="headerlink" title="8. 遇到 GUI 解决不了的冲突，命令行参数了解一下。"></a>8. 遇到 GUI 解决不了的冲突，命令行参数了解一下。</h3><p>大杀器，说多了都是泪……</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上内容是笔者几乎照搬着对 git 的理解来总结的，可能并不成熟。不过经过了一年的实践，这些“规范”操作的确达到了避免冲突的目的，且远没有复杂过 git rebase 工具流。</p><p>制定规范是一回事，更应该要求团队成员继续加深对版本管理库的理解，思考分支合并存在的意义，养成更好的提交习惯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;svn 给笔者的一大印象就是非常容易产生冲突，特别是项目加入新人后，由于初期没有强硬地制定规范，导致后期合并代码时灾难连天。决定在此分享这些“亡羊补牢”的规则，也算是避免 svn 产生合并冲突的一点经验。&lt;/p&gt;
    
    </summary>
    
      <category term="SVN" scheme="https://claude-ray.github.io/categories/SVN/"/>
    
    
      <category term="SVN" scheme="https://claude-ray.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Nginx改写$args未生效踩坑</title>
    <link href="https://claude-ray.github.io/2019/01/24/nginx-proxypass-args/"/>
    <id>https://claude-ray.github.io/2019/01/24/nginx-proxypass-args/</id>
    <published>2019-01-24T13:45:26.000Z</published>
    <updated>2019-01-24T16:22:28.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>原始需求是通过 nginx 在请求链接中增加一个固定参数 custom_param，方法很简单，在 location 中重设 <code>$args</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in location xxx</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$args</span> <span class="variable">$args</span>&amp;custom_param=<span class="built_in">test</span>;</span><br><span class="line">proxy_pass http://remote_host;</span><br></pre></td></tr></table></figure><p>顺便说一下，即使链接中没有参数也不影响一般服务端解析，符号<code>?</code>会自动加上，如上例子 proxy_pass 后会路径将变成 <a href="http://remote_host/xxx?&amp;custom_param=test。" target="_blank" rel="noopener">http://remote_host/xxx?&amp;custom_param=test。</a></p><p>但问题是在服务器如此配置 nginx 后，custom_param 参数并没有如约发给 remote_host……</p><a id="more"></a><p>最终在 nginx change log 中找到了原因。</p><blockquote><p><a href="http://nginx.org/en/CHANGES" target="_blank" rel="noopener">http://nginx.org/en/CHANGES</a> Changes with nginx 1.7.1          27 May 2014</p><p>Bugfix: a “proxy_pass” directive without URI part might use original<br>  request after the $args variable was set.<br>  Thanks to Yichun Zhang.</p></blockquote><p>可以看出是nginx很早就修复的 bug，可以肯定到手的 nginx 版本太旧了，又试了版本 1.6.2 果然也存在问题，bug 存在的版本不多，相关资料很少。</p><p>在不升级 nginx 的情况下，修复方案是采用旧的参数附加方式<code>$uri$is_args$args</code>，如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="variable">$args</span> <span class="variable">$args</span>&amp;custom_param=<span class="built_in">test</span>;</span><br><span class="line">proxy_pass http://remote_host<span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>很多软件包的疑难杂症都可以试着查阅 change log，而且有些情况下检索历史变更比查 issue 更方便。之前<a href="https://claude-ray.github.io/2017/10/05/lodash-3-to-4/">《lodash3升级4踩坑》</a> 一文提到的 lodash 升级大版本导致 merge 用法变更，也是查 history 定位到了问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;原始需求是通过 nginx 在请求链接中增加一个固定参数 custom_param，方法很简单，在 location 中重设 &lt;code&gt;$args&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# in location xxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$args&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$args&lt;/span&gt;&amp;amp;custom_param=&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;proxy_pass http://remote_host;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;顺便说一下，即使链接中没有参数也不影响一般服务端解析，符号&lt;code&gt;?&lt;/code&gt;会自动加上，如上例子 proxy_pass 后会路径将变成 &lt;a href=&quot;http://remote_host/xxx?&amp;amp;custom_param=test。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://remote_host/xxx?&amp;amp;custom_param=test。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但问题是在服务器如此配置 nginx 后，custom_param 参数并没有如约发给 remote_host……&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://claude-ray.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://claude-ray.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的if使用须知</title>
    <link href="https://claude-ray.github.io/2019/01/09/nginx-ifisevil/"/>
    <id>https://claude-ray.github.io/2019/01/09/nginx-ifisevil/</id>
    <published>2019-01-09T14:42:14.000Z</published>
    <updated>2019-01-09T16:49:29.027Z</updated>
    
    <content type="html"><![CDATA[<p>被 nginx 官方自我批判的 if 语句，《<a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/" target="_blank" rel="noopener">If Is Evil</a>》——这应该成为每位开发者初次使用 nginx 的 if 之前必读的文章。</p><p>即使一年前就开始用 nginx 和 if 的组合做跳转，但涉及的功能太简单，没能见识到它的真面目。当我在多个 if 内处理 proxy_pass 时，噩梦就降临了。</p><a id="more"></a><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>if 本身是 rewrite 模块的一部分，然而在非 rewrite 环境下也可以用，显然这是错误的用法，进而引发很多出乎意料的问题。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>最直观的还是来看代码，下面引用 If Is Evil 的 <a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/#examples" target="_blank" rel="noopener">Example 部分</a>，用 30 秒即可浏览大部分 evil 场景。</p><ol><li><p>只有X-Second会被设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /only-one-if &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> X-First <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> X-Second <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>proxy_pass 不会生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy-pass-uri &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="comment"># nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>try_files 不会生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /if-try-files &#123;</span><br><span class="line">     <span class="attribute">try_files</span>  /file  <span class="variable">@fallback</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">         <span class="comment"># nothing</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nginx 将发出段错误信号 SIGSEGV</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /crash &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="comment"># fastcgi_pass here</span></span><br><span class="line">        <span class="attribute">fastcgi_pass</span>  <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="comment"># no handler here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>alias 无法正确地被继承到由 if 创建的隐式嵌套 location 中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* ^/if-and-alias/(?&lt;file&gt;.*)</span> &#123;</span><br><span class="line">    <span class="attribute">alias</span> /tmp/<span class="variable">$file</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">        <span class="comment"># nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h1><p>既然 if 如此之坑，最好的办法就是乖乖禁用 if，但拗不过诸位喜欢折腾的灵魂，特殊场景还是可以用的。下面列举最常见的避坑方案。</p><h2 id="官方认可的两种用法"><a href="#官方认可的两种用法" class="headerlink" title="官方认可的两种用法"></a>官方认可的两种用法</h2><p>再怎么说，if 就是为 rewrite 服务的，如果有 bug 早被封杀了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#The only 100% safe things which may be done inside if in a location context are:</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">return</span> ...;</span><br><span class="line"><span class="attribute">rewrite</span> ... <span class="literal">last</span>;</span><br></pre></td></tr></table></figure><h2 id="proxy-pass-中及时-break"><a href="#proxy-pass-中及时-break" class="headerlink" title="proxy_pass 中及时 break"></a>proxy_pass 中及时 break</h2><p>当处理各种跳转逻辑时，假设你不期望因为多传了个等于 “hi” 的参数 parma2，就导致 <code>param1 ~ &quot;hello&quot;</code> 的跳转失败，那么应该在合适的地方增加 break。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy-pass-uri &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$true</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$arg_param1</span> <span class="regexp">~ "hello")</span> &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/;</span><br><span class="line">      <span class="comment"># 这里的break将阻止下面if的执行</span></span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$arg_param2</span> <span class="regexp">~ "hi")</span> &#123;</span><br><span class="line">      <span class="comment"># anything</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8082/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此外，也可以通过调整 if 的顺序来规避风险，但是容错率比 break 低了很多</p></blockquote><h2 id="使用-lua"><a href="#使用-lua" class="headerlink" title="使用 lua"></a>使用 lua</h2><blockquote><p><a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module</a></p></blockquote><p>具体来说，通过安装 lua 和 lua-nginx-module( 或 OpenResty ) 来增强 nginx 的逻辑处理，可以称为目前最流行有效的处理方案。lua 扩展带来的好处远不止 if 语句的避坑，例如带来方便地读取 POST 请求体的内容等便利操作。网上资料齐全，这里不多赘述。</p><h2 id="使用-njs"><a href="#使用-njs" class="headerlink" title="使用 njs"></a>使用 njs</h2><blockquote><p><a href="http://nginx.org/en/docs/njs/index.html" target="_blank" rel="noopener">http://nginx.org/en/docs/njs/index.html</a></p></blockquote><p>nginScript (njs) 是 nginx 在 2015 发布的 javascript 配置方案。类似于 lua-nginx-module，它也需要安装相关依赖模块。但有官方做后盾的 njs，比起 lua 要更为轻量，不需要完整的语言运行环境。并且针对 nginx 环境进行设计，理论上有更高的优化空间。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，坑点和避坑的方法都阐明了，如果还想了解 nginx if 背后的机制，或有其他疑问，请继续探寻《If Is Evil》原文吧！</p><p>再次附上传送门：</p><blockquote><p><a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被 nginx 官方自我批判的 if 语句，《&lt;a href=&quot;https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;If Is Evil&lt;/a&gt;》——这应该成为每位开发者初次使用 nginx 的 if 之前必读的文章。&lt;/p&gt;
&lt;p&gt;即使一年前就开始用 nginx 和 if 的组合做跳转，但涉及的功能太简单，没能见识到它的真面目。当我在多个 if 内处理 proxy_pass 时，噩梦就降临了。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://claude-ray.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://claude-ray.github.io/tags/Nginx/"/>
    
      <category term="If Is Evil" scheme="https://claude-ray.github.io/tags/If-Is-Evil/"/>
    
  </entry>
  
  <entry>
    <title>crontab 中使用 pm2</title>
    <link href="https://claude-ray.github.io/2019/01/03/pm2-crontab/"/>
    <id>https://claude-ray.github.io/2019/01/03/pm2-crontab/</id>
    <published>2019-01-03T13:56:48.000Z</published>
    <updated>2019-01-03T15:37:16.453Z</updated>
    
    <content type="html"><![CDATA[<p>本篇不是讲如何处理代码内的定时任务，而是聊聊怎么借助 crontab 等工具，定时操作 pm2 (指令)。例如，定时重启 pm2 中的进程、定时执行 pm2 save 保存运行状态，等等。</p><a id="more"></a><h1 id="重启进程"><a href="#重启进程" class="headerlink" title="重启进程"></a>重启进程</h1><p><code>pm2 --help</code> 可以看到 pm2 自带 cron 功能，但功能仅限于重启进程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: pm2 [cmd] app</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">-c --cron &lt;cron_pattern&gt;     restart a running process based on a cron pattern</span><br></pre></td></tr></table></figure><h1 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h1><p>执行指令包括重启 pm2 内的进程，并且可以定时调用 pm2 做任何它支持的事。这种情况下，使用系统层面的 <code>crontab</code> 就对啦。</p><p>需要注意的是，pm2 在 crontab 中的运行 PATH 和 在 命令行 shell 中直接执行并不一样，因此会报 <code>pm2: command not found</code> 之类的错。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line">*/1 * * * * pm2 flush &gt; /var/<span class="built_in">log</span>/pm2flush.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>解决方法是在使用pm2的脚本中指定环境变量，参考<code>which pm2</code>，找出pm2的bin路径。</p><p>一般是通过<code>npm i pm2 -g</code>全局安装，环境变量是<code>/urs/local/node/bin</code>。如果你使用nvm，那可能是<code>/home/yourname/.nvm/versions/node/vX.X.X/bin</code>。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="pm2-flush"><a href="#pm2-flush" class="headerlink" title="pm2 flush"></a>pm2 flush</h2><p>例如我们要定时清除 pm2 的 log 文件，节省磁盘空间，可以使用 pm2 自带的 flush 命令。</p><h2 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h2><p>一种是直接在定时器执行 pm2 flush</p><blockquote><p>PATH 的指定要结合具体情况，常见的做法是命令行 <code>echo $PATH</code>，把输出内容补到指令的 PATH 中</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/node/bin</span><br><span class="line"></span><br><span class="line">*/1 * * * * pm2 flush &gt; /var/<span class="built_in">log</span>/pm2flush.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="间接执行"><a href="#间接执行" class="headerlink" title="间接执行"></a>间接执行</h2><p>另一种是定时调用任务脚本，通过脚本间接执行 pm2 flush，这样方便我们同时做其他处理，如删除日志前先打包备份。</p><p>在 crontab 中，内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/node/bin</span><br><span class="line"></span><br><span class="line">*/1 * * * * sh /home/root/pm2flush.sh &gt; /var/<span class="built_in">log</span>/pm2flush.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>再来看它执行的 <code>pm2flush.sh</code> 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果crontab中不指定node bin的PATH，也可以在这里通过如下方式指定</span></span><br><span class="line"><span class="comment"># PATH=$PATH:/usr/local/node/bin</span></span><br><span class="line">pm2 flush</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇不是讲如何处理代码内的定时任务，而是聊聊怎么借助 crontab 等工具，定时操作 pm2 (指令)。例如，定时重启 pm2 中的进程、定时执行 pm2 save 保存运行状态，等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="pm2" scheme="https://claude-ray.github.io/tags/pm2/"/>
    
      <category term="crontab" scheme="https://claude-ray.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>PM2 cluster + log4js？并不理想的组合</title>
    <link href="https://claude-ray.github.io/2018/12/21/pm2-cluster-log4js/"/>
    <id>https://claude-ray.github.io/2018/12/21/pm2-cluster-log4js/</id>
    <published>2018-12-21T12:49:03.000Z</published>
    <updated>2018-12-22T05:53:09.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="log4js-和-cluster"><a href="#log4js-和-cluster" class="headerlink" title="log4js 和 cluster"></a>log4js 和 cluster</h1><h2 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h2><p>node cluster 多个进程同时写一个文件是不安全的，通常会只选择一个 master 进程负责写入，其他 worker 进程则将数据传输到 master。</p><p>log4js 的写策略正是如此，但默认只适用于 node 原生的 cluster 模式，然而通过 pm2 启动的进程都是 worker。</p><p>官方提供的方案是安装 <code>pm2-intercom</code>，并在代码配置 log4js 时打开 <code>pm2: true</code> 选项，其原理也是选出一个负责写文件的主进程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 install pm2-intercom</span><br></pre></td></tr></table></figure><h2 id="选举-master"><a href="#选举-master" class="headerlink" title="选举 master"></a>选举 master</h2><p>log4js 选择主进程的<a href="https://github.com/log4js-node/log4js-node/blob/master/lib/clustering.js#L13" target="_blank" rel="noopener">策略</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPM2Master = <span class="function"><span class="params">()</span> =&gt;</span> pm2 &amp;&amp; process.env[pm2InstanceVar] === <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">const</span> isMaster = <span class="function"><span class="params">()</span> =&gt;</span> disabled || cluster.isMaster || isPM2Master();</span><br></pre></td></tr></table></figure><p>其中 disabled 是 log4js 的 disableClustering 选项，设置为 true 后，所有进程都将作为 master 进而拥有写文件的权限，这并没有解决安全问题。它存在的价值后面再说。</p><p>每个 pm2 启动的进程都有唯一的 process.env.NODE_APP_INSTANCE 标识，<code>process.env.NODE_APP_INSTANCE === &#39;0&#39;</code> 是常见的选择主从方式。多进程同时记录日志时，也可以用此方式指定唯一的进程负责写文件，避免同时写文件造成的冲突。此外 pm2 支持通过重命名 <code>instance_var</code> 来改变 process.env 的标记名，目的是解决和 <code>node-config</code> 包共用导致的异常。</p><blockquote><p><a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="noopener">关于 NODE_APP_INSTANCE 的 pm2 官方说明</a></p></blockquote><h2 id="问题多多的-pm2-intercom-方案"><a href="#问题多多的-pm2-intercom-方案" class="headerlink" title="问题多多的 pm2-intercom 方案"></a>问题多多的 pm2-intercom 方案</h2><p>当下 pm2 的版本是 3.2.x，而 <code>pm2-intercom</code> 在 pm2 2.x 版本就已经存在异常了，重复日志甚至丢失日志，或在开发环境运行正常，到了线上莫名失败。更严重的是，当一个 pm2 box 内运行多个 cluster 模式启动的应用时，日志记录会变得混乱，各应用的日志都乱入了最早启动的应用的日志文件中。</p><p>log4js 的维护者 nomiddlename 也在 issue 中表示 pm2-intercom 存在着古怪的问题。</p><blockquote><p><a href="https://github.com/log4js-node/log4js-node/issues/265#issuecomment-359126674" target="_blank" rel="noopener">log4js doesn’t work with PM2 cluster mode #265</a></p><p>pm2-intercom has always seemed a bit dodgy - for some people it never works at all anyway. It didn’t need to use git clone when I installed it. Best plan might be to use the disableClustering option in your log4js config, log to stdout and let pm2 handle the files as it normally would.</p></blockquote><h2 id="option-disableClustering-不是银弹"><a href="#option-disableClustering-不是银弹" class="headerlink" title="option.disableClustering 不是银弹"></a>option.disableClustering 不是银弹</h2><p>上面再次提到 <code>disableClustering</code> 选项，不错，pm2-intercom 异常的场景可以拿它救场，但要注意它本身不适用于直接写文件，每个进程都被赋予了 master 权限，会再次引发开篇的冲突问题。官方文档也明确警示：<code>Be careful if you’re logging to files</code>。</p><h1 id="pm2-intercom-粗解"><a href="#pm2-intercom-粗解" class="headerlink" title="pm2-intercom 粗解"></a>pm2-intercom 粗解</h1><p>这个模块是简易的 IPC，借助 <code>process.send</code> 方法，将多个进程的数据包统一发送至 pm2 中编号为 0 的 pm2-intercom 进程，此进程再将收到的消息推送至项目进程中的一个。</p><p>在log4js的使用场景，表现为各自进程的日志首先发送到 pm2-intercom，由 pm2-intercom 分发到全部进程，但只有 log4js isMaster 才会写文件。</p><p>分发代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">packet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>.forEachLimit(process_list, <span class="number">3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">proc, next</span>) </span>&#123;</span><br><span class="line">    sendDataToProcessId(proc.pm_id, packet);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果想在多进程模式下记录日志到同一个文件，log4js + PM2 显然不是完美的组合。winston 也有人反馈丢日志的<a href="https://github.com/winstonjs/winston/issues/1466" target="_blank" rel="noopener">问题</a>，但没有得到官方回复前，仍需要验证。</p><p>如果想安全记录日志，还是得分多个文件，或脱离 pm2，像 egg 一样在框架层面自行 cluster。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://log4js-node.github.io/log4js-node/clustering.html" target="_blank" rel="noopener">Clustering / Multi-process Logging</a></p></li><li><p><a href="https://www.npmjs.com/package/lj-log4js-pm2intercom" target="_blank" rel="noopener">to-fix-pm2-intercom-in-pm2-2x</a></p></li><li><p><a href="https://juejin.im/post/5b7d0e20f265da43231f00d4" target="_blank" rel="noopener">再说打日志你不会，pm2 + log4js，你值得拥有</a></p></li><li><p><a href="https://www.jianshu.com/p/20fcb3672723" target="_blank" rel="noopener">探索 PM2 Cluster 模式下 Log4js 日志丢失</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;log4js-和-cluster&quot;&gt;&lt;a href=&quot;#log4js-和-cluster&quot; class=&quot;headerlink&quot; title=&quot;log4js 和 cluster&quot;&gt;&lt;/a&gt;log4js 和 cluster&lt;/h1&gt;&lt;h2 id=&quot;写策略&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="pm2" scheme="https://claude-ray.github.io/tags/pm2/"/>
    
      <category term="log4js" scheme="https://claude-ray.github.io/tags/log4js/"/>
    
      <category term="pm2-intercom" scheme="https://claude-ray.github.io/tags/pm2-intercom/"/>
    
  </entry>
  
  <entry>
    <title>iptables不会主动断开已有连接</title>
    <link href="https://claude-ray.github.io/2018/12/15/iptables-wont-block-established-connections/"/>
    <id>https://claude-ray.github.io/2018/12/15/iptables-wont-block-established-connections/</id>
    <published>2018-12-15T10:48:24.000Z</published>
    <updated>2018-12-15T10:53:28.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>源于一次mongodb超时问题查证。具体表现是服务响应异常缓慢，mongodb查询甚至报出<code>cursor id not found</code>。</p><p>在排除网络连通性和主机自身因素后，继续回归mongo连接异常的点上，直到发现mongo集群的iptables没有开放mongo端口，开墙后一切恢复正常。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>据查证，防火墙关闭mongo端口已经有一段时间了，为什么很久之后才出现连接不上的问题？</p><p>因为iptables不会主动断开已经建立的连接，这不是<code>packet filter</code>的职责所在。</p><p>但它依然有办法阻止现有连接的数据包（iptables的过滤基于数据包而非连接）。只不过，通常我们配置防火墙时都会加上一句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>这就导致了已建立的连接可以无障碍地继续传输。</p><p>正因如此，mongodb的连接早已建立，被iptables置于ESTABLISHED中，所以不会受到仅ip规则更新的影响。当业务进程重启、网络波动等情况导致旧的连接断开时，将无法重新连接。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://linux.die.net/man/8/iptables" target="_blank" rel="noopener">https://linux.die.net/man/8/iptables</a></p><p><a href="https://serverfault.com/questions/785691/how-does-one-close-all-existing-tcp-connections-on-some-ports-using-iptables" target="_blank" rel="noopener">https://serverfault.com/questions/785691/how-does-one-close-all-existing-tcp-connections-on-some-ports-using-iptables</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What?&quot;&gt;&lt;/a&gt;What?&lt;/h2&gt;&lt;p&gt;源于一次mongodb超时问题查证。具体表现是服务响应异常缓慢，mongodb查询甚至报出&lt;code&gt;cursor id
      
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="iptables" scheme="https://claude-ray.github.io/tags/iptables/"/>
    
      <category term="Linux" scheme="https://claude-ray.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>总结node处理GBK编码</title>
    <link href="https://claude-ray.github.io/2018/12/12/node-gbk-sum/"/>
    <id>https://claude-ray.github.io/2018/12/12/node-gbk-sum/</id>
    <published>2018-12-12T14:49:00.000Z</published>
    <updated>2018-12-18T16:17:00.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Node内部不支持直接操作GBK字符串，而实际也并不需要如此。</p><p>总的原则是，gbk的逻辑仅保留在输入和输出，内部处理一律使用utf8。编码转换主要基于<code>iconv-lite</code>库。</p><p>总结已经写在了前头，下面再列举几种http服务中常见的处理场景。</p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><h2 id="请求返回值"><a href="#请求返回值" class="headerlink" title="请求返回值"></a>请求返回值</h2><p>最常用且容易处理，通常我们使用<code>request</code>发起http请求，options中设置<code>encoding: null</code>，这样返回的res.body为buffer，再对buffer进行解码<code>iconv.decode(res.body, encoding)</code>。</p><blockquote><p>引用：<a href="https://claude-ray.github.io/2018/02/26/request%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/#%E7%BC%96%E7%A0%81">request返回值中文乱码问题</a></p></blockquote><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>这里直接用<code>iconv-lite</code>处理略显复杂，建议上<a href="https://github.com/node-modules/urlencode" target="_blank" rel="noopener">urlencode</a>。</p><p>post请求时stringify整个body对象，用options.form提交。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlencode.stringify(body, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure><p>querystring则stringify后再拼到url中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlencode.stringify(qs, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="接口返回值"><a href="#接口返回值" class="headerlink" title="接口返回值"></a>接口返回值</h2><p>以koa举例，返回值先使用<code>iconv-lite</code>转为gbk Buffer，随后设置响应头的content-type。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.body = iconv.encode(<span class="string">'你好'</span>, <span class="string">'gbk'</span>);</span><br><span class="line">ctx.type = <span class="string">'text/plain; charset=gbk'</span>;</span><br></pre></td></tr></table></figure><h2 id="接口参数"><a href="#接口参数" class="headerlink" title="接口参数"></a>接口参数</h2><p>同样以koa举例，结合<code>koa-bodyparser</code>，一般http method的原始参数分布在ctx.request.rawBody和ctx.request.querystring中，使用<code>urlencode.parse</code>解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urlencode.parse(ctx.request.rawBody, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br><span class="line">urlencode.parse(ctx.request.querystring, &#123;<span class="attr">charset</span>: <span class="string">'gbk'</span>&#125;);</span><br></pre></td></tr></table></figure><p>特别地，当请求格式为multipart或json时需要结合具体情况具体分析。</p><p>例如，使用<code>busboy</code>等multipart解析库会将请求body挂在<code>ctx.request.body</code>上，规范的请求方式是会对字符进行url encode的，这时可以按gbk编码对字段decode（由于不能直接url decode，实际处理方法为转hex后再经buffer解码）。</p><p>如果请求参数是经过binary处理的，则binary decode。</p><p>综上，处理姿势大致如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lodash.mapValues(ctx.request.body, value =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> buff = <span class="regexp">/^(%\w&#123;2&#125;)+$/</span>.test(value)</span><br><span class="line">    ? Buffer.from(value.replace(<span class="regexp">/%/g</span>, <span class="string">''</span>), <span class="string">'hex'</span>)</span><br><span class="line">    : Buffer.from(value, <span class="string">'binary'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iconv.decode(buff, <span class="string">'gbk'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>想兼容更多情况是比较复杂的，即使做基础服务也不必包容所有不规范的传值，大可以拒绝解析，因此按需调整即可。</p><p>如果能约定使用十六进制传参更好，处理hex就不需要在参数获取上额外操作了。可惜一般用到gbk的场景都是难以变更的、需要兼容的，否则肯定是让调用方改传utf8，皆大欢喜。</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>默认方式（<code>encoding: null</code>）就是操作buffer，iconv转换无压力。</p><p>读：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buff = fs.readFileSync(<span class="string">'test.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iconv.decode(buff, <span class="string">'gbk'</span>));</span><br></pre></td></tr></table></figure><p>写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buff = iconv.encode(<span class="string">'你好'</span>, <span class="string">'gbk'</span>);</span><br><span class="line">fs.writeFileSync(<span class="string">'test.txt'</span>, buff);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Node内部不支持直接操作GBK字符串，而实际也并不需要如此。&lt;/p&gt;
&lt;p&gt;总的原则是，gbk的逻辑仅保留在输入和输出，内部处理一律使用u
      
    
    </summary>
    
      <category term="Node.js" scheme="https://claude-ray.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://claude-ray.github.io/tags/Node-js/"/>
    
      <category term="String" scheme="https://claude-ray.github.io/tags/String/"/>
    
      <category term="GBK编码" scheme="https://claude-ray.github.io/tags/GBK%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置ss-local客户端</title>
    <link href="https://claude-ray.github.io/2018/12/01/ss-local/"/>
    <id>https://claude-ray.github.io/2018/12/01/ss-local/</id>
    <published>2018-12-01T14:03:28.000Z</published>
    <updated>2019-05-15T04:37:02.099Z</updated>
    
    <content type="html"><![CDATA[<p>ss-local是<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a>提供的客户端工具，若想正常使用需先准备一台机器部署shadowsocks服务端以作为代理。</p><h2 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h2><p>Ubuntu 16以上直接用apt安装，其他发行版可以查阅文档<a href="https://github.com/shadowsocks/shadowsocks-libev#installation" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev#installation</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure><h2 id="二、编辑配置文件"><a href="#二、编辑配置文件" class="headerlink" title="二、编辑配置文件"></a>二、编辑配置文件</h2><h3 id="配置代理服地址"><a href="#配置代理服地址" class="headerlink" title="配置代理服地址"></a>配置代理服地址</h3><p>参考config.json修改local.json，填写代理服务器的地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/shadowsocks-libev/config.json /etc/shadowsocks-libev/local.json</span><br><span class="line">sudo vi /etc/shadowsocks-libev/local.json</span><br></pre></td></tr></table></figure><p>建议<code>local_port</code>不要使用默认的1080，例如改为1081。主要是避免和ss-server（在安装后默认作为<code>shadowsocks-libev.service</code>启动）抢占端口，或者选择手动停掉ss-server。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: <span class="string">"代理服地址"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>: <span class="string">"代理服端口"</span>,</span><br><span class="line">  <span class="attr">"local_port"</span>: <span class="number">1081</span>,</span><br><span class="line">  <span class="attr">"password"</span>: <span class="string">"代理服密码"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>: <span class="number">60</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"chacha20-ietf-poly1305"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置systemd-service"><a href="#配置systemd-service" class="headerlink" title="配置systemd service"></a>配置systemd service</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /lib/systemd/system/shadowsocks-libev-local@.service</span><br></pre></td></tr></table></figure><p>替换其中ExecStart的配置路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/ss-local -c /etc/shadowsocks-libev/local.json</span><br></pre></td></tr></table></figure><h2 id="三、启动服务"><a href="#三、启动服务" class="headerlink" title="三、启动服务"></a>三、启动服务</h2><p>使用systemctl或service管理服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">sudo systemctl start shadowsocks-libev-local@.</span><br><span class="line"><span class="comment">#或 $ sudo service shadowsocks-libev-local@.service start</span></span><br><span class="line"><span class="comment">#查看运行情况</span></span><br><span class="line">sudo systemctl status shadowsocks-libev-local@.</span><br><span class="line"><span class="comment">#配置开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks-libev-local@.</span><br></pre></td></tr></table></figure><h2 id="四、配置PAC文件"><a href="#四、配置PAC文件" class="headerlink" title="四、配置PAC文件"></a>四、配置PAC文件</h2><p>PAC的语法是js，规则非常简单。核心点是实现<code>FindProxyForURL</code>函数，判断当前域名是否使用代理，不需要代理的域名直接返回<code>DIRECT</code>。</p><p>因此内容自己实现就可以，但不支持es6及以上特定，这里参考<a href="https://github.com/JinnLynn/genpac" target="_blank" rel="noopener">genpac</a>加上endsWith的polyfill。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 端口号按之前配置local.json的local_port来填写，默认1080</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="string">'SOCKS5 127.0.0.1:1081'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 走代理的host</span></span><br><span class="line"><span class="keyword">var</span> hosts = [</span><br><span class="line">  <span class="string">'evernote.com'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hosts.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (host.endsWith(hosts[i])) <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * REF:</span></span><br><span class="line"><span class="comment"> * genpac 2.1.0</span></span><br><span class="line"><span class="comment"> * https://github.com/JinnLynn/genpac</span></span><br><span class="line"><span class="comment"> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.endsWith) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.endsWith = <span class="function"><span class="keyword">function</span>(<span class="params">searchString, position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subjectString = <span class="keyword">this</span>.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> position !== <span class="string">'number'</span> || !<span class="built_in">isFinite</span>(position) || <span class="built_in">Math</span>.floor(position) !== position || position &gt; subjectString.length) &#123;</span><br><span class="line">        position = subjectString.length;</span><br><span class="line">    &#125;</span><br><span class="line">    position -= searchString.length;</span><br><span class="line">    <span class="keyword">var</span> lastIndex = subjectString.indexOf(searchString, position);</span><br><span class="line">    <span class="keyword">return</span> lastIndex !== <span class="number">-1</span> &amp;&amp; lastIndex === position;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、配置系统代理"><a href="#五、配置系统代理" class="headerlink" title="五、配置系统代理"></a>五、配置系统代理</h2><p>这一步可以通过export来设置，但没找到automatic的配置方法，干脆用系统自带的proxy来处理。按如下步骤一路点，最后填上PAC文件的路径。</p><p>Network -&gt; Network proxy -&gt; Automatic -&gt; Configuration URL -&gt; <code>/etc/proxy/my.pac</code></p><h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><blockquote><p>2019-05-15 更新</p></blockquote><p>最近安装了几次 Ubuntu 18.04 都无法通过上述系统配置实现自动跳转，仅全局代理生效，尚未找出原因。</p><p>目前推荐的解决方案是通过 <code>SwitchyOmega</code> 等 chrome 插件设置自动代理，一次配置随处生效（也可以在单机上选择性关闭），操作更为方案，无须再到系统配置了。</p><ul><li>SwitchyOmega: <a href="https://github.com/FelisCatus/SwitchyOmega" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega</a></li></ul>]]></content>
    
    <summary type="html">
    
      近期Evernote因为局域网问题不能使用了，作为重要工具不能离手，于是借助ss代理方式应急一下。ubuntu18没有特别好用的ss GUI，故选择了命令行工具ss-local。部署没难度，操作流程是翻文档加自己探索，个人认为比网上其他攻略简单，分享出来希望有助于大家解决网络疑难杂症。同时声明，本文只涉及客户端部署，evernote.com截止文章发布时间并没有被墙，请使用国内云服务器代理合规站点。
    
    </summary>
    
      <category term="Linux" scheme="https://claude-ray.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://claude-ray.github.io/tags/Ubuntu/"/>
    
      <category term="proxy" scheme="https://claude-ray.github.io/tags/proxy/"/>
    
  </entry>
  
</feed>
